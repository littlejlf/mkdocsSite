<!DOCTYPE html>
<html class="no-js" lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<link href="../assets/images/favicon.png" rel="icon"/>
<meta content="mkdocs-1.5.3, mkdocs-material-9.5.3" name="generator"/>
<title>Test - My Docs from lf</title>
<link href="../assets/stylesheets/main.50c56a3b.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
<link href="../css/heti.css" rel="stylesheet"/>
<script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
<link href="../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
        html.glightbox-open { overflow: initial; height: 100%; }
        .gslide-title { margin-top: 0px; user-select: text; }
        .gslide-desc { color: #666; user-select: text; }
        .gslide-image img { background: white; }
        
            .gscrollbar-fixer { padding-right: 15px; }
            .gdesc-inner { font-size: 0.75rem; }
            body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
            body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
            body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}
            </style> <script src="../assets/javascripts/glightbox.min.js"></script></head>
<body dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#_1">
          跳转至
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header md-header--shadow" data-md-component="header">
<nav aria-label="页眉" class="md-header__inner md-grid">
<a aria-label="My Docs from lf" class="md-header__button md-logo" data-md-component="logo" href=".." title="My Docs from lf">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 4v6l-2-2-2 2V4H9v16h10V4h-2M3 7V5h2V4a2 2 0 0 1 2-2h12c1.05 0 2 .95 2 2v16c0 1.05-.95 2-2 2H7c-1.05 0-2-.95-2-2v-1H3v-2h2v-4H3v-2h2V7H3m2-2v2h2V5H5m0 14h2v-2H5v2m0-6h2v-2H5v2Z"></path></svg>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            My Docs from lf
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Test
            
          </span>
</div>
</div>
</div>
<script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
<div class="md-header__source">
<a class="md-source" data-md-component="source" href="https://github.com/littlejlf/mkdocsSite" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"></path></svg>
</div>
<div class="md-source__repository">
    GitHub
  </div>
</a>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="导航栏" class="md-nav md-nav--primary" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="My Docs from lf" class="md-nav__button md-logo" data-md-component="logo" href=".." title="My Docs from lf">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 4v6l-2-2-2 2V4H9v16h10V4h-2M3 7V5h2V4a2 2 0 0 1 2-2h12c1.05 0 2 .95 2 2v16c0 1.05-.95 2-2 2H7c-1.05 0-2-.95-2-2v-1H3v-2h2v-4H3v-2h2V7H3m2-2v2h2V5H5m0 14h2v-2H5v2m0-6h2v-2H5v2Z"></path></svg>
</a>
    My Docs from lf
  </label>
<div class="md-nav__source">
<a class="md-source" data-md-component="source" href="https://github.com/littlejlf/mkdocsSite" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"></path></svg>
</div>
<div class="md-source__repository">
    GitHub
  </div>
</a>
</div>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_1" type="checkbox"/>
<label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
<span class="md-ellipsis">
    编译原理
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_1_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_1">
<span class="md-nav__icon md-icon"></span>
            编译原理
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="..">
<span class="md-ellipsis">
    None
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_2" type="checkbox"/>
<label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
<span class="md-ellipsis">
    静态分析、程序检测
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_2_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_2">
<span class="md-nav__icon md-icon"></span>
            静态分析、程序检测
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="..">
<span class="md-ellipsis">
    None
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_3" type="checkbox"/>
<label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
<span class="md-ellipsis">
    并发
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_3_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_3">
<span class="md-nav__icon md-icon"></span>
            并发
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="..">
<span class="md-ellipsis">
    None
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_4" type="checkbox"/>
<label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
<span class="md-ellipsis">
    程序语言
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_4_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_4">
<span class="md-nav__icon md-icon"></span>
            程序语言
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="..">
<span class="md-ellipsis">
    None
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_5" type="checkbox"/>
<label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
<span class="md-ellipsis">
    操作系统
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_5_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_5">
<span class="md-nav__icon md-icon"></span>
            操作系统
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="..">
<span class="md-ellipsis">
    None
  </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--nested">
<input class="md-nav__toggle md-toggle" id="__nav_6" type="checkbox"/>
<label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
<span class="md-ellipsis">
    随记内容
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<nav aria-expanded="false" aria-labelledby="__nav_6_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_6">
<span class="md-nav__icon md-icon"></span>
            随记内容
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="..">
<span class="md-ellipsis">
    Welcome to MkDocs
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
      目录
    </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#_1">
<span class="md-ellipsis">
      基础运算
    </span>
</a>
<nav aria-label="基础运算" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_2">
<span class="md-ellipsis">
      函数调用
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#list">
<span class="md-ellipsis">
      List
    </span>
</a>
<nav aria-label="List" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#texas_ranges">
<span class="md-ellipsis">
      Texas ranges
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#list_comprehension">
<span class="md-ellipsis">
      List comprehension
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#tuple">
<span class="md-ellipsis">
      Tuple
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#syntax_in_functions">
<span class="md-ellipsis">
      Syntax in Functions
    </span>
</a>
<nav aria-label="Syntax in Functions" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#pattern_matching">
<span class="md-ellipsis">
      Pattern matching
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#guard_syntax">
<span class="md-ellipsis">
      Guard syntax
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#case_expressions">
<span class="md-ellipsis">
      Case expressions
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#where">
<span class="md-ellipsis">
      where
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#let">
<span class="md-ellipsis">
      let
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#if_statement">
<span class="md-ellipsis">
      if statement
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#higher_order_functions">
<span class="md-ellipsis">
      Higher Order Functions
    </span>
</a>
<nav aria-label="Higher Order Functions" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#currying">
<span class="md-ellipsis">
      Currying
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_3">
<span class="md-ellipsis">
      一些高阶函数
    </span>
</a>
<nav aria-label="一些高阶函数" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#zipwith">
<span class="md-ellipsis">
      zipWith
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#flip">
<span class="md-ellipsis">
      flip
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#map">
<span class="md-ellipsis">
      map
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#filter">
<span class="md-ellipsis">
      filter
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#takewhile">
<span class="md-ellipsis">
      takeWhile
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#function_application">
<span class="md-ellipsis">
      Function application
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#function_composition">
<span class="md-ellipsis">
      Function Composition
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#lambda">
<span class="md-ellipsis">
      lambda
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#foldscan">
<span class="md-ellipsis">
      fold和scan
    </span>
</a>
<nav aria-label="fold和scan" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#foldl">
<span class="md-ellipsis">
      foldl
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#foldr">
<span class="md-ellipsis">
      foldr
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#scanl_scanr">
<span class="md-ellipsis">
      scanl 和 scanr
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#foldr_foldl">
<span class="md-ellipsis">
      使用 foldr 编写 foldl
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#modules">
<span class="md-ellipsis">
      Modules
    </span>
</a>
<nav aria-label="Modules" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#modules_1">
<span class="md-ellipsis">
      编写 Modules
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#types_typeclasses">
<span class="md-ellipsis">
      Types &amp; Typeclasses
    </span>
</a>
<nav aria-label="Types &amp; Typeclasses" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#types">
<span class="md-ellipsis">
      Types
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#typeclasses">
<span class="md-ellipsis">
      Typeclasses
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#type_variables">
<span class="md-ellipsis">
      Type variables
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#type">
<span class="md-ellipsis">
      定义新 Type
    </span>
</a>
<nav aria-label="定义新 Type" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#type_1">
<span class="md-ellipsis">
      导出 Type
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#record_syntax">
<span class="md-ellipsis">
      Record Syntax
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#type_parameters">
<span class="md-ellipsis">
      Type parameters
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#either">
<span class="md-ellipsis">
      Either
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#derived_instances">
<span class="md-ellipsis">
      Derived instances
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#type_synonyms">
<span class="md-ellipsis">
      Type synonyms
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#newtype_keyword">
<span class="md-ellipsis">
      newtype keyword
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#recursive_data_structures">
<span class="md-ellipsis">
      Recursive data structures
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#typeclass">
<span class="md-ellipsis">
      定义新 Typeclass
    </span>
</a>
<nav aria-label="定义新 Typeclass" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_4">
<span class="md-ellipsis">
      手动创建实例
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#functor_typeclass">
<span class="md-ellipsis">
      Functor Typeclass
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#kinds">
<span class="md-ellipsis">
      Kinds
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#inputoutput">
<span class="md-ellipsis">
      Input/Output
    </span>
</a>
<nav aria-label="Input/Output" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#haskell">
<span class="md-ellipsis">
      运行 Haskell 程序
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_5">
<span class="md-ellipsis">
      输出文本
    </span>
</a>
<nav aria-label="输出文本" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#do_block">
<span class="md-ellipsis">
      do block
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_6">
<span class="md-ellipsis">
      输入文本
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#io">
<span class="md-ellipsis">
      其他 IO 相关函数用法
    </span>
</a>
<nav aria-label="其他 IO 相关函数用法" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#return">
<span class="md-ellipsis">
      return
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#when">
<span class="md-ellipsis">
      when
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sequence">
<span class="md-ellipsis">
      sequence
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#mapm_mapm_">
<span class="md-ellipsis">
      mapM &amp; mapM_
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#forever">
<span class="md-ellipsis">
      forever
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#form">
<span class="md-ellipsis">
      forM
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#getcontents">
<span class="md-ellipsis">
      getContents
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#interact">
<span class="md-ellipsis">
      interact
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_7">
<span class="md-ellipsis">
      文件和流
    </span>
</a>
<nav aria-label="文件和流" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#openfile">
<span class="md-ellipsis">
      openFile
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#withfile">
<span class="md-ellipsis">
      withFile
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#readfile">
<span class="md-ellipsis">
      readFile
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#writefile">
<span class="md-ellipsis">
      writeFile
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#appendfile">
<span class="md-ellipsis">
      appendFile
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#buffer">
<span class="md-ellipsis">
      buffer
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#opentempfile">
<span class="md-ellipsis">
      openTempFile
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_8">
<span class="md-ellipsis">
      路径操作
    </span>
</a>
<nav aria-label="路径操作" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#getcurrentdirectory">
<span class="md-ellipsis">
      getCurrentDirectory
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#removefile">
<span class="md-ellipsis">
      removeFile
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#renamefile">
<span class="md-ellipsis">
      renameFile
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#doesfileexist">
<span class="md-ellipsis">
      doesFileExist
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#command_line_arguments">
<span class="md-ellipsis">
      Command line arguments
    </span>
</a>
<nav aria-label="Command line arguments" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#getargs">
<span class="md-ellipsis">
      getArgs
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#getprogname">
<span class="md-ellipsis">
      getProgName
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#randomness">
<span class="md-ellipsis">
      Randomness
    </span>
</a>
<nav aria-label="Randomness" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#random">
<span class="md-ellipsis">
      random
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#randoms">
<span class="md-ellipsis">
      randoms
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#randomr">
<span class="md-ellipsis">
      randomR
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#randomrs">
<span class="md-ellipsis">
      randomRs
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#getstdgen">
<span class="md-ellipsis">
      getStdGen
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#newstdgen">
<span class="md-ellipsis">
      newStdGen
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#exceptions">
<span class="md-ellipsis">
      Exceptions
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#functors">
<span class="md-ellipsis">
      Functors
    </span>
</a>
<nav aria-label="Functors" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#functor">
<span class="md-ellipsis">
      Functor 实例
    </span>
</a>
<nav aria-label="Functor 实例" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_9">
<span class="md-ellipsis">
      []
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#maybe">
<span class="md-ellipsis">
      Maybe
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#either_a">
<span class="md-ellipsis">
      Either a
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#io_1">
<span class="md-ellipsis">
      IO
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#a">
<span class="md-ellipsis">
      (,) a
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#-_r">
<span class="md-ellipsis">
      (-&gt;) r
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#functor_laws">
<span class="md-ellipsis">
      Functor Laws
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#intuition">
<span class="md-ellipsis">
      Intuition
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_10">
<span class="md-ellipsis">
      常用函数
    </span>
</a>
<nav aria-label="常用函数" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_11">
<span class="md-ellipsis">
      &lt;$&gt;
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_12">
<span class="md-ellipsis">
      $&gt;
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#void">
<span class="md-ellipsis">
      void
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#applicative_functor">
<span class="md-ellipsis">
      Applicative Functor
    </span>
</a>
<nav aria-label="Applicative Functor" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#applicative_functor_1">
<span class="md-ellipsis">
      Applicative Functor 实例
    </span>
</a>
<nav aria-label="Applicative Functor 实例" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#maybe_1">
<span class="md-ellipsis">
      Maybe
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_13">
<span class="md-ellipsis">
      []
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#io_2">
<span class="md-ellipsis">
      IO
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#-_r_1">
<span class="md-ellipsis">
      (-&gt;) r
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ziplist">
<span class="md-ellipsis">
      ZipList
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#applicative_functor_laws">
<span class="md-ellipsis">
      Applicative Functor Laws
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#intuition_1">
<span class="md-ellipsis">
      Intuition
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_14">
<span class="md-ellipsis">
      常用函数
    </span>
</a>
<nav aria-label="常用函数" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#lifta_lifta2_lifta3">
<span class="md-ellipsis">
      liftA &amp; liftA2 &amp; liftA3
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_15">
<span class="md-ellipsis">
      &lt;* &amp; *&gt;
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_16">
<span class="md-ellipsis">
      &lt;**&gt;
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#when_unless">
<span class="md-ellipsis">
      when &amp; unless
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sequencea">
<span class="md-ellipsis">
      sequenceA
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#monad">
<span class="md-ellipsis">
      Monad
    </span>
</a>
<nav aria-label="Monad" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#monad_1">
<span class="md-ellipsis">
      Monad 实例
    </span>
</a>
<nav aria-label="Monad 实例" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#maybe_2">
<span class="md-ellipsis">
      Maybe
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_17">
<span class="md-ellipsis">
      []
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#io_3">
<span class="md-ellipsis">
      IO
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#-_r_2">
<span class="md-ellipsis">
      (-&gt;) r
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#do-notation">
<span class="md-ellipsis">
      do-notation
    </span>
</a>
<nav aria-label="do-notation" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#applicativedo">
<span class="md-ellipsis">
      ApplicativeDo
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#monad_laws">
<span class="md-ellipsis">
      Monad Laws
    </span>
</a>
<nav aria-label="Monad Laws" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_18">
<span class="md-ellipsis">
      组合运算符（&gt;=&gt;）形式
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#do-notation_1">
<span class="md-ellipsis">
      do-notation 形式
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#intuition_2">
<span class="md-ellipsis">
      Intuition
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_19">
<span class="md-ellipsis">
      常用函数
    </span>
</a>
<nav aria-label="常用函数" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#liftm_ap">
<span class="md-ellipsis">
      liftM &amp; ap
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sequence_1">
<span class="md-ellipsis">
      sequence
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#replicatem">
<span class="md-ellipsis">
      replicateM
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#mapm_form">
<span class="md-ellipsis">
      mapM &amp; forM
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_20">
<span class="md-ellipsis">
      =&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#monadfail">
<span class="md-ellipsis">
      MonadFail
    </span>
</a>
<nav aria-label="MonadFail" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#monadfail_1">
<span class="md-ellipsis">
      MonadFail 实例
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#monadfail_law">
<span class="md-ellipsis">
      MonadFail Law
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#semigroup">
<span class="md-ellipsis">
      Semigroup
    </span>
</a>
<nav aria-label="Semigroup" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#semigroup_law">
<span class="md-ellipsis">
      Semigroup Law
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nonempty">
<span class="md-ellipsis">
      补：NonEmpty
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#monoid">
<span class="md-ellipsis">
      Monoid
    </span>
</a>
<nav aria-label="Monoid" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#monoid_1">
<span class="md-ellipsis">
      Monoid 实例
    </span>
</a>
<nav aria-label="Monoid 实例" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#a_1">
<span class="md-ellipsis">
      [a]
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ordering">
<span class="md-ellipsis">
      Ordering
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#sum_product">
<span class="md-ellipsis">
      Sum &amp; Product
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#all_any">
<span class="md-ellipsis">
      All &amp; Any
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#monoid_a_maybe_a">
<span class="md-ellipsis">
      Monoid a =&gt; Maybe a
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#first_last">
<span class="md-ellipsis">
      First &amp; Last
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#min_max">
<span class="md-ellipsis">
      Min &amp; Max
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_21">
<span class="md-ellipsis">
      元组
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#monoid_laws">
<span class="md-ellipsis">
      Monoid Laws
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#monoidal_classes">
<span class="md-ellipsis">
      Monoidal classes
    </span>
</a>
<nav aria-label="Monoidal classes" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#alternative">
<span class="md-ellipsis">
      Alternative
    </span>
</a>
<nav aria-label="Alternative" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#alternative_1">
<span class="md-ellipsis">
      Alternative 实例
    </span>
</a>
<nav aria-label="Alternative 实例" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_22">
<span class="md-ellipsis">
      []
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#maybe_3">
<span class="md-ellipsis">
      Maybe
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#ziplist_1">
<span class="md-ellipsis">
      ZipList
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#alternative_laws">
<span class="md-ellipsis">
      Alternative Laws
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_23">
<span class="md-ellipsis">
      常用函数
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#monadplus">
<span class="md-ellipsis">
      MonadPlus
    </span>
</a>
<nav aria-label="MonadPlus" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#monadplus_1">
<span class="md-ellipsis">
      MonadPlus实例
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#monadplus_laws">
<span class="md-ellipsis">
      MonadPlus Laws
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_24">
<span class="md-ellipsis">
      常用函数
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#arrowplus">
<span class="md-ellipsis">
      ArrowPlus
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#typeclasses_1">
<span class="md-ellipsis">
      一些其它 Typeclasses
    </span>
</a>
<nav aria-label="一些其它 Typeclasses" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#foldable">
<span class="md-ellipsis">
      Foldable
    </span>
</a>
<nav aria-label="Foldable" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#foldable_1">
<span class="md-ellipsis">
      Foldable 实例
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_25">
<span class="md-ellipsis">
      常用函数
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#traversable">
<span class="md-ellipsis">
      Traversable
    </span>
</a>
<nav aria-label="Traversable" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#traversable_1">
<span class="md-ellipsis">
      Traversable 实例
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#traversable_laws">
<span class="md-ellipsis">
      Traversable Laws
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#bifunctor">
<span class="md-ellipsis">
      Bifunctor
    </span>
</a>
<nav aria-label="Bifunctor" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#bifunctor_laws">
<span class="md-ellipsis">
      Bifunctor Laws
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#category">
<span class="md-ellipsis">
      Category
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#arrow">
<span class="md-ellipsis">
      Arrow
    </span>
</a>
<nav aria-label="Arrow" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#arrow_notation">
<span class="md-ellipsis">
      Arrow notation
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#arrowchoice">
<span class="md-ellipsis">
      ArrowChoice
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#arrowzero_arrowplus">
<span class="md-ellipsis">
      ArrowZero &amp; ArrowPlus
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_26">
<span class="md-ellipsis">
      例子
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#haskell_1">
<span class="md-ellipsis">
      Haskell 与范畴论
    </span>
</a>
<nav aria-label="Haskell 与范畴论" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#category_1">
<span class="md-ellipsis">
      范畴（Category）
    </span>
</a>
<nav aria-label="范畴（Category）" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_27">
<span class="md-ellipsis">
      范畴公理
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#mathbfhask">
<span class="md-ellipsis">
      $\mathbf{Hask}$ 范畴
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#functors_1">
<span class="md-ellipsis">
      函子（Functors）
    </span>
</a>
<nav aria-label="函子（Functors）" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_28">
<span class="md-ellipsis">
      函子公理
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#mathbfhask_1">
<span class="md-ellipsis">
      $\mathbf{Hask}$ 范畴上的函子
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#monads">
<span class="md-ellipsis">
      单子（Monads）
    </span>
</a>
<nav aria-label="单子（Monads）" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#_29">
<span class="md-ellipsis">
      单子公理
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#_30">
<span class="md-ellipsis">
      后记
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#reference">
<span class="md-ellipsis">
      Reference
    </span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<h1>Test</h1>
<blockquote>
<p><span>Haskell<span class="heti-spacing"> </span></span>是一种标准化的，通用的纯函数式编程语言，有惰性求值和强静态类型。它的命名源自美国逻辑学家哈斯凯尔<span class="heti-skip"><span class="heti-spacing"> </span>·<span class="heti-spacing"> </span></span>加里，他在数理逻辑方面上的工作使得函数式编程语言有了广泛的基础。在<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>中<heti-adjacent class="heti-adjacent-quarter">，</heti-adjacent>“函数是第一类对象”。作为一门函数编程语言，主要控制结构是函数。<span>Haskell<span class="heti-spacing"> </span></span>语言是<span class="heti-skip"><span class="heti-spacing"> </span>1990<span class="heti-spacing"> </span></span>年在编程语言<span class="heti-skip"><span class="heti-spacing"> </span>Miranda<span class="heti-spacing"> </span></span>的基础上标准化的，并且以<span class="heti-skip"><span class="heti-spacing"> </span>λ<span class="heti-spacing"> </span></span>演算为基础发展而来。这也是为什么<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>语言以希腊字母 “λ”（Lambda）作为自己的标志。<span>Haskell<span class="heti-spacing"> </span></span>具有“证明即程序、命题为类型”的特征。
</p><div style="text-align: right">———— 维基百科</div>
</blockquote>
<h2 id="_1">基础运算<a class="headerlink" href="#_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h2>
<ul>
<li><code>+ - * / ()</code>：加减乘除</li>
<li><code>div</code>：整除</li>
<li><code>mod</code>：取模</li>
<li><code>True False</code>：布尔值</li>
<li><code>|| &amp;&amp; not</code>：或且非</li>
<li><code>==</code>：条件判断，相等</li>
<li><code>/=</code>：条件判断，不等</li>
</ul>
<h3 id="_2">函数调用<a class="headerlink" href="#_2" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<p><span>Haskell<span class="heti-spacing"> </span></span>中调用函数不加括号，先写出函数名，然后逐个列出参数，用空格隔开：</p>
<pre><code class="language-haskell">ghci&gt; max 1 2
2
</code></pre>
<p>前缀（prefix）函数与中缀（infix）函数转换：</p>
<ul>
<li>对前缀函数加<code>``</code>使其变成中缀函数</li>
<li>对中缀函数加<code>()</code>使其变成前缀函数</li>
</ul>
<pre><code class="language-haskell">ghci&gt; 4 `div` 2
2
ghci&gt; 1 `max` 2
2
ghci&gt; (+) 1 2
3
ghci&gt; (||) True False
True
</code></pre>
<hr/>
<h2 id="list">List<a class="headerlink" href="#list" title="Permanent link">#</a></h2>
<p>列表是<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>中很常见的数据类型，和<span class="heti-skip"><span class="heti-spacing"> </span>Python<span class="heti-spacing"> </span></span>中不同，<span>Haskell<span class="heti-spacing"> </span></span>中的列表中的所有元素必须是同一个类型。</p>
<p>以下是列表常用的函数：</p>
<ul>
<li><code>(++)</code> :: [a] -&gt; [a] -&gt; [a]：合并两个列表</li>
<li><code>(:)</code> :: a -&gt; [a] -&gt; [a]：将单个元素并入列表。<span>[1, 2, 3]<span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span>1:2:3:[]<span class="heti-spacing"> </span></span>的语法糖</li>
<li><code>(!!)</code> :: [a] -&gt; Int -&gt; a：通过索引取出某个位置上的元素。<span>a !! 1<span class="heti-spacing"> </span></span>相当于<span class="heti-skip"><span class="heti-spacing"> </span>Python<span class="heti-spacing"> </span></span>中的<span><span class="heti-spacing"> </span>a[1]</span></li>
<li><code>head</code> :: [a] -&gt; a：返回列表的第一个元素</li>
<li><code>tail</code> :: [a] -&gt; [a]：返回列表中除去第一个元素后的列表（若只有一个元素则返回空列表<span><span class="heti-spacing"> </span>[]</span>）</li>
<li><code>last</code> :: [a] -&gt; a：返回列表中的最后一个元素</li>
<li><code>init</code> :: [a] -&gt; [a]：返回列表中除去最后一个元素后的列表</li>
<li><code>length</code> :: Foldable t =&gt; t a -&gt; Int：返回列表的长度</li>
<li><code>null</code> :: Foldable t =&gt; t a -&gt; Bool：返回列表是否为空</li>
<li><code>reverse</code> :: [a] -&gt; [a]：返回翻转后的列表</li>
<li><code>take</code> :: Int -&gt; [a] -&gt; [a]：返回列表<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>的前<span class="heti-skip"><span class="heti-spacing"> </span>n<span class="heti-spacing"> </span></span>个元素的列表<span><span class="heti-spacing"> </span>(take n a)</span></li>
<li><code>drop</code> :: Int -&gt; [a] -&gt; [a]：返回列表<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>中除去前<span class="heti-skip"><span class="heti-spacing"> </span>n<span class="heti-spacing"> </span></span>个元素后的列表<span><span class="heti-spacing"> </span>(drop n a)</span></li>
<li><code>maximum</code> :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最大值</li>
<li><code>minimum</code> :: (Foldable t, Ord a) =&gt; t a -&gt; a：返回列表中的最小值</li>
<li><code>sum</code> :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的和</li>
<li><code>product</code> :: (Foldable t, Num a) =&gt; t a -&gt; a：返回列表中所有元素的积</li>
<li><code>elem</code> :: (Foldable t, Eq a) =&gt; t a -&gt; Bool：判断值<span class="heti-skip"><span class="heti-spacing"> </span>n<span class="heti-spacing"> </span></span>是否在列表<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>中
    <code>haskell
    elem n a
    -- 或
    n `elem` a --用``包上可以变成中缀函数使用</code></li>
</ul>
<h3 id="texas_ranges">Texas ranges<a class="headerlink" href="#texas_ranges" title="Permanent link">#</a></h3>
<p>使用<code>..</code>可以表示出范围并自动推导：</p>
<pre><code class="language-haskell">ghci&gt; [1 .. 10]  
[1,2,3,4,5,6,7,8,9,10]  
ghci&gt; ['a' .. 'z']  
"abcdefghijklmnopqrstuvwxyz"  
ghci&gt; ['K' .. 'Z']  
"KLMNOPQRSTUVWXYZ" 
ghci&gt; [2, 4 .. 20]  
[2,4,6,8,10,12,14,16,18,20]  
ghci&gt; [3, 6 .. 20]  
[3,6,9,12,15,18]
ghci&gt; [5, 4 .. 1]
[5,4,3,2,1]
</code></pre>
<p>也可以用来生成无穷列表，如<span><span class="heti-spacing"> </span>[1..]</span>、[1, 3..]。同时也有函数可以生成无穷列表：</p>
<ul>
<li><code>cycle</code> :: [a] -&gt; [a]：将原列表不断循环生成无穷列表</li>
<li><code>repeat</code> :: a -&gt; [a]：将传入的值不断重复生成无穷列表<ul>
<li><code>replicate</code> :: Int -&gt; a -&gt; [a]：将值<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>重复<span class="heti-skip"><span class="heti-spacing"> </span>n<span class="heti-spacing"> </span></span>次，返回生成的列表<span><span class="heti-spacing"> </span>(replicate n a)</span></li>
</ul>
</li>
</ul>
<h3 id="list_comprehension">List comprehension<a class="headerlink" href="#list_comprehension" title="Permanent link">#</a></h3>
<p><span>Haskell<span class="heti-spacing"> </span></span>中也有列表推导，形式是一个中括号，左侧为表达式，右侧为变量的范围和约束条件</p>
<pre><code class="language-haskell">ghci&gt; [x * 2 | x &lt;- [1 .. 10]]  
[2,4,6,8,10,12,14,16,18,20]  
ghci&gt; [x * 2 | x &lt;- [1 .. 10], x * 2 &gt;= 12]  
[12,14,16,18,20]
ghci&gt; [ x | x &lt;- [50 .. 100], x `mod` 7 == 3]  
[52,59,66,73,80,87,94]   
ghci&gt; [x * y | x &lt;- [2, 5, 10], y &lt;- [8, 10, 11]]  
[16,20,22,40,50,55,80,100,110]
</code></pre>
<hr/>
<h2 id="tuple">Tuple<a class="headerlink" href="#tuple" title="Permanent link">#</a></h2>
<p><span>Haskell<span class="heti-spacing"> </span></span>中的元组可以有不同长度，元素可以有不同类型。并且一个元组的类型由其中所有元素的类型共同决定。它的常用函数：</p>
<ul>
<li><code>fst</code> :: (a, b) -&gt; a：返回含有两个元素元组中的第一个元素</li>
<li><code>snd</code> :: (a, b) -&gt; b：返回含有两个元素元组中的第二个元素</li>
<li><code>zip</code> :: [a] -&gt; [b] -&gt; [(a, b)]：接收两个列表，返回一个列表，每个元素是依次将两个列表中元素配对成的二元组</li>
</ul>
<hr/>
<h2 id="syntax_in_functions">Syntax in Functions<a class="headerlink" href="#syntax_in_functions" title="Permanent link">#</a></h2>
<p>函数可以直接定义：</p>
<pre><code class="language-haskell">plus x y = x + y
</code></pre>
<p>这时<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>会自动推断函数的类型为<span><span class="heti-spacing"> </span>(Num a) =&gt; a -&gt; a -&gt; a</span>。但是最好在定义函数前声明函数的类型：</p>
<pre><code class="language-haskell">plus :: (Num a) =&gt; a -&gt; a -&gt; a
plus x y = x + y
</code></pre>
<h3 id="pattern_matching">Pattern matching<a class="headerlink" href="#pattern_matching" title="Permanent link">#</a></h3>
<p>定义函数时可以使用模式匹配语法。运行时依次将输入与给出的模式相匹配，如果匹配，就执行对应操作；不匹配，就继续与下一个模式相匹配，直到匹配成功，也因此，最后必须要给出一种通用的匹配来接收与给出模式全不匹配的输入。如：</p>
<pre><code class="language-haskell">factorial :: (Integral a) =&gt; a -&gt; a  
factorial 0 = 1  
factorial n = n * factorial (n - 1)  
</code></pre>
<pre><code class="language-haskell">first :: (a, b, c) -&gt; a  
first (x, _, _) = x  

second :: (a, b, c) -&gt; b  
second (_, y, _) = y  

third :: (a, b, c) -&gt; c  
third (_, _, z) = z  
</code></pre>
<p>其中 <code>_</code> 表示任何值，且不关心它的内容，只是用来占位</p>
<p>列表的<span class="heti-skip"><span class="heti-spacing"> </span>(:)<span class="heti-spacing"> </span></span>操作也可以用来进行模式匹配：</p>
<pre><code class="language-haskell">head' :: [a] -&gt; a  
head' [] = error "Can't call head on an empty list, dummy!"  
head' (x:_) = x

sum' :: (Num a) =&gt; [a] -&gt; a  
sum' [] = 0  
sum' (x:xs) = x + sum' xs  
</code></pre>
<p>但<span class="heti-skip"><span class="heti-spacing"> </span>(++)<span class="heti-spacing"> </span></span>操作不可以用来模式匹配</p>
<p>在针对列表进行模式匹配时，如果同时需要整个列表、列表的第一个值、列表除第一个值外的内容，可以使用 <code>xs@(q:qs)</code>。比如<span class="heti-skip"><span class="heti-spacing"> </span>[1, 2, 3]<span class="heti-spacing"> </span></span>通过 <code>xs@(q:qs)</code> 匹配后，<span>xs<span class="heti-spacing"> </span></span>为<span><span class="heti-spacing"> </span>[1, 2, 3]</span>，<span>q<span class="heti-spacing"> </span></span>为<span><span class="heti-spacing"> </span>1</span>，<span>qs<span class="heti-spacing"> </span></span>为<span><span class="heti-spacing"> </span>[2, 3]</span></p>
<h3 id="guard_syntax">Guard syntax<a class="headerlink" href="#guard_syntax" title="Permanent link">#</a></h3>
<p>在函数的定义中，也可以使用守卫（guard）语法：</p>
<pre><code class="language-haskell">max' :: (Ord a) =&gt; a -&gt; a -&gt; a  
max' a b   
    | a &gt; b     = a  
    | otherwise = b 
</code></pre>
<p>先给出传入的参数变量，然后下一行缩进后加<span><span class="heti-spacing"> </span>|</span>，<span>|<span class="heti-spacing"> </span></span>后面等号前表示进行的判断，如果为<span class="heti-skip"><span class="heti-spacing"> </span>True<span class="heti-spacing"> </span></span>则返回这个等号后面的值；如果为<span class="heti-skip"><span class="heti-spacing"> </span>False<span class="heti-spacing"> </span></span>则继续判断下一行，直到<span><span class="heti-spacing"> </span>otherwise</span></p>
<h3 id="case_expressions">Case expressions<a class="headerlink" href="#case_expressions" title="Permanent link">#</a></h3>
<p>在函数的定义中，也可以使用<span class="heti-skip"><span class="heti-spacing"> </span>case<span class="heti-spacing"> </span></span>表达式来配合模式匹配使用：</p>
<pre><code class="language-haskell">case expression of pattern -&gt; result  
                   pattern -&gt; result
                   ...  
</code></pre>
<p>例如：</p>
<pre><code class="language-haskell">head' :: [a] -&gt; a  
head' [] = error "No head for empty lists!"  
head' (x:_) = x  
-- 等价于：
head' :: [a] -&gt; a  
head' xs = case xs of [] -&gt; error "No head for empty lists!"  
                      (x:_) -&gt; x  
</code></pre>
<pre><code class="language-haskell">describeList :: [a] -&gt; String  
describeList xs = "The list is " ++ case xs of [] -&gt; "empty."  
                                               [x] -&gt; "a singleton list."   
                                               xs -&gt; "a longer list."  
-- 等价于：
describeList :: [a] -&gt; String  
describeList xs = "The list is " ++ what xs  
    where what [] = "empty."  
          what [x] = "a singleton list."  
          what xs = "a longer list." 
</code></pre>
<h3 id="where">where<a class="headerlink" href="#where" title="Permanent link">#</a></h3>
<p>声明在函数定义中要使用的局部变量，可以使用<span class="heti-skip"><span class="heti-spacing"> </span>where<span class="heti-spacing"> </span></span>关键字：</p>
<pre><code class="language-haskell">initials :: String -&gt; String -&gt; String  
initials firstname lastname = [f] ++ ". " ++ [l] ++ "."  
    where (f:_) = firstname  
          (l:_) = lastname  
</code></pre>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span>where<span class="heti-spacing"> </span></span>中，也可以使用上面的模式匹配</p>
<h3 id="let">let<a class="headerlink" href="#let" title="Permanent link">#</a></h3>
<p><code>let &lt;bindings&gt; in &lt;expression&gt;</code> 语法可以在函数的定义中使用，也可以在普通算式或列表中使用：</p>
<pre><code class="language-haskell">cylinder :: (RealFloat a) =&gt; a -&gt; a -&gt; a  
cylinder r h = 
    let sideArea = 2 * pi * r * h  
        topArea = pi * r ^2  
    in  sideArea + 2 * topArea  
</code></pre>
<pre><code class="language-haskell">ghci&gt; 4 * (let a = 9 in a + 1) + 2  
42 
ghci&gt; [let square x = x * x in (square 5, square 3, square 2)]  
[(25,9,4)] 
</code></pre>
<h3 id="if_statement">if statement<a class="headerlink" href="#if_statement" title="Permanent link">#</a></h3>
<p><span>Haskell<span class="heti-spacing"> </span></span>中的<span class="heti-skip"><span class="heti-spacing"> </span>if<span class="heti-spacing"> </span></span>语句为：</p>
<pre><code class="language-haskell">if ... then ...
else ...
-- or if ... then ... else ...
-- or
if ... then ...
else if ... then ...
else ...
</code></pre>
<p>其中最后一个<span class="heti-skip"><span class="heti-spacing"> </span>else<span class="heti-spacing"> </span></span>无论如何也不可以省去</p>
<hr/>
<h2 id="higher_order_functions">Higher Order Functions<a class="headerlink" href="#higher_order_functions" title="Permanent link">#</a></h2>
<h3 id="currying">Currying<a class="headerlink" href="#currying" title="Permanent link">#</a></h3>
<p><span>Haskell<span class="heti-spacing"> </span></span>中的函数是柯里化（Currying）的，可以看作所有函数都只接收一个参数，而接收两个参数的函数实际上是这个函数接收了第一个参数后返回了一个接收第二个参数的函数，然后用这个函数接收第二个参数，返回最终的结果。比如<span class="heti-skip"><span class="heti-spacing"> </span>max<span class="heti-spacing"> </span></span>函数，它的类型签名是：</p>
<p style="text-align: center;">max :: Ord a =&gt; a -&gt; a -&gt; a</p>
<p>可以看成<span><span class="heti-spacing"> </span>a -&gt; (a -&gt; a)</span>，即接收一个参数，返回一个类型为<span class="heti-skip"><span class="heti-spacing"> </span>a -&gt; a<span class="heti-spacing"> </span></span>的函数。比如<span class="heti-skip"><span class="heti-spacing"> </span>max 1<span class="heti-spacing"> </span></span>的类型签名是：</p>
<p style="text-align: center;">max 1 :: (Ord a, Num a) =&gt; a -&gt; a</p>
<p>因此<span><span class="heti-spacing"> </span>max 1 2</span>，也就等同于<span><span class="heti-spacing"> </span>(max 1) 2</span>，即将函数<span class="heti-skip"><span class="heti-spacing"> </span>max 1<span class="heti-spacing"> </span></span>应用在数字<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>上</p>
<p>同时，函数也可以接收函数作为参数，参数有函数的函数就被称为高阶函数（Higher Order Functions）</p>
<h3 id="_3">一些高阶函数<a class="headerlink" href="#_3" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<h4 id="zipwith">zipWith<a class="headerlink" href="#zipwith" title="Permanent link">#</a></h4>
<p style="text-align: center;">zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</p>
<p>第一个参数为一个函数，然后接收两个列表，将其对应元素传入接收的函数中，得到的结果组成一个新的列表。如果两个传入的列表长度不同，以最短的列表为准，长列表中超出的元素省略。用例：</p>
<pre><code class="language-haskell">ghci&gt; zipWith (+) [4,2,5,6] [2,6,2,3]  
[6,8,7,9]  
ghci&gt; zipWith max [6,3,2,1] [7,3,1,5]  
[7,3,2,5]  
</code></pre>
<h4 id="flip">flip<a class="headerlink" href="#flip" title="Permanent link">#</a></h4>
<p style="text-align: center;">flip :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</p>
<p><span>flip<span class="heti-spacing"> </span></span>函数接收一个二元函数，返回一个新的二元函数，将其输入的两个参数顺序反过来：</p>
<pre><code class="language-haskell">ghci&gt; zip [1,2,3,4,5] "hello"
[(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')]
ghci&gt; flip zip [1,2,3,4,5] "hello"  
[('h',1),('e',2),('l',3),('l',4),('o',5)]
</code></pre>
<h4 id="map">map<a class="headerlink" href="#map" title="Permanent link">#</a></h4>
<p style="text-align: center;">map :: (a -&gt; b) -&gt; [a] -&gt; [b]</p>
<p><span>map<span class="heti-spacing"> </span></span>函数接收一个函数<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>和一个列表<span><span class="heti-spacing"> </span>a</span>，将函数<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>应用在列表<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>的每个元素中，并返回得到的所有结果组成的列表<span><span class="heti-spacing"> </span>b</span>：</p>
<pre><code class="language-haskell">ghci&gt; map (+3) [1,5,3,1,6]  
[4,8,6,4,9]  
</code></pre>
<h4 id="filter">filter<a class="headerlink" href="#filter" title="Permanent link">#</a></h4>
<p style="text-align: center;">filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</p>
<p><span>filter<span class="heti-spacing"> </span></span>函数接收一个函数<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>和一个列表<span><span class="heti-spacing"> </span>a</span>，将列表<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>中的每个元素传入函数<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>中，如果结果为<span class="heti-skip"><span class="heti-spacing"> </span>True<span class="heti-spacing"> </span></span>就保留，结果为<span class="heti-skip"><span class="heti-spacing"> </span>False<span class="heti-spacing"> </span></span>就抛弃，返回所有保留的元素组成的新列表：</p>
<pre><code class="language-haskell">ghci&gt; filter even [1..10]  
[2,4,6,8,10] 
</code></pre>
<h4 id="takewhile">takeWhile<a class="headerlink" href="#takewhile" title="Permanent link">#</a></h4>
<p style="text-align: center;">takeWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</p>
<p><span>takeWhile<span class="heti-spacing"> </span></span>函数接收一个函数<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>和一个列表<span><span class="heti-spacing"> </span>a</span>，将列表<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>中从左向右每个元素传入函数<span><span class="heti-spacing"> </span>f</span>，直到结果为<span class="heti-skip"><span class="heti-spacing"> </span>False<span class="heti-spacing"> </span></span>停止，返回停止前传入的所有元素组成的新列表：</p>
<pre><code class="language-haskell">ghci&gt; takeWhile (/=' ') "word1 word2"
"word1"
</code></pre>
<h3 id="function_application">Function application<a class="headerlink" href="#function_application" title="Permanent link">#</a></h3>
<p>函数应用可以使用 <code>$</code>，<code>$</code> 是一个函数，它的类型是：</p>
<p style="text-align: center;">($) :: (a -&gt; b) -&gt; a -&gt; b</p>
<p>它可以改变函数结合优先级，将左侧函数应用于全部右侧内容上，相当于给右侧整体加上了括号。否则函数默认左结合，会依次向右应用而不会应用在整体上。</p>
<pre><code class="language-haskell">f $ g x
-- 等价于
f (g x)
-----
f g x
-- 等价于
(f g) x
</code></pre>
<h3 id="function_composition">Function Composition<a class="headerlink" href="#function_composition" title="Permanent link">#</a></h3>
<p>函数复合可以使用 <code>.</code>，<code>.</code> 也是一个函数，它的类型是：</p>
<p style="text-align: center;">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</p>
<p>定义是：</p>
<p style="text-align: center;">f . g = \x -&gt; f (g x)</p>
<p>但是函数复合的优先级要比函数执行低，比如：</p>
<pre><code class="language-haskell">sum . replicate 5 . max 6.7 8.9
</code></pre>
<p>会先执行<span class="heti-skip"><span class="heti-spacing"> </span>max 6.7 8.9<span class="heti-spacing"> </span></span>并返回<span><span class="heti-spacing"> </span>8.9</span>，然后将<span><span class="heti-spacing"> </span>sum</span>、replicate 5、<span>8.9<span class="heti-spacing"> </span></span>复合，但两个函数无法和一个值<span class="heti-skip"><span class="heti-spacing"> </span>(8.9)<span class="heti-spacing"> </span></span>复合，所以会抛出异常。因此要使用 <code>$</code>来规定先复合再执行：</p>
<pre><code class="language-haskell">sum . replicate 5 . max 6.7 $ 8.9
</code></pre>
<h3 id="lambda">lambda<a class="headerlink" href="#lambda" title="Permanent link">#</a></h3>
<p><span>Haskell<span class="heti-spacing"> </span></span>语言中的<span class="heti-skip"><span class="heti-spacing"> </span>lambda<span class="heti-spacing"> </span></span>表达式是用 <code>\</code> 来表示的（因为看着像<span><span class="heti-spacing"> </span>$\mathtt{\lambda}$</span><heti-adjacent class="heti-adjacent-half">？</heti-adjacent>）<br/>
具体语法是</p>
<pre><code class="language-haskell">\para1 para2 ... -&gt; return
</code></pre>
<p><span>"-&gt;"<span class="heti-spacing"> </span></span>前的<span class="heti-skip"><span class="heti-spacing"> </span>para1 para2 ...<span class="heti-spacing"> </span></span>是传入参数，单个多个都可以，需要用空格隔开；<span>"-&gt;"<span class="heti-spacing"> </span></span>后的<span class="heti-skip"><span class="heti-spacing"> </span>return<span class="heti-spacing"> </span></span>是计算得到的返回值。一般需要用括号将整个表达式括起来，防止返回值部分一直向右延伸。</p>
<h3 id="foldscan"><span>fold<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>scan</span><a class="headerlink" href="#foldscan" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<p><span>fold<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>scan<span class="heti-spacing"> </span></span>都接收三个参数（一个二元函数，一个初始值<span><span class="heti-spacing"> </span>accumulator</span>，一个要折叠的列表<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，<span>fold<span class="heti-spacing"> </span></span>返回一个值，而<span class="heti-skip"><span class="heti-spacing"> </span>scan<span class="heti-spacing"> </span></span>返回一个列表<br/>
传入的二元函数 <code>f :: a -&gt; b -&gt; b</code> 将 accumulator 和从列表中取出的值一同传入（l 则 accumulator 在左边为第一个参数，r 则 accumulator 在右边为第二个参数）</p>
<h4 id="foldl">foldl<a class="headerlink" href="#foldl" title="Permanent link">#</a></h4>
<p>左折叠，每次从列表最左侧取出一个值，和<span class="heti-skip"><span class="heti-spacing"> </span>accumulator<span class="heti-spacing"> </span></span>一起传入二元函数，并且<span class="heti-skip"><span class="heti-spacing"> </span>accumulator<span class="heti-spacing"> </span></span>在左边为第一个参数，如：</p>
<pre><code class="language-haskell">foldl f a xs
</code></pre>
<p>它的结果计算过程为</p>
<pre><code class="language-haskell">&gt; foldl f a [x1, x2, x3]
[1.] a = f a x1
[2.] a = f a x2 = f (f a x1) x2
[3.] a = f a x3 = f (f (f a x1) x2) x3
</code></pre>
<p>可以看出<span class="heti-skip"><span class="heti-spacing"> </span>f (f a x1) x2<span class="heti-spacing"> </span></span>其实就是<span><span class="heti-spacing"> </span>foldl f a [x1, x2]</span>
而且因此，foldl 在计算时最外层需要找到 x3，这样如果 xs 是一个无穷列表，那么将无法计算，陷入无穷。所以 foldl 虽然看起来从左边取值，但是函数需要从右侧展开，并不适用于无穷列表</p>
<h4 id="foldr">foldr<a class="headerlink" href="#foldr" title="Permanent link">#</a></h4>
<p>右折叠，每次从列表最右侧取出一个值，和<span class="heti-skip"><span class="heti-spacing"> </span>accumulator<span class="heti-spacing"> </span></span>一起传入二元函数，并且<span class="heti-skip"><span class="heti-spacing"> </span>accumulator<span class="heti-spacing"> </span></span>在右边为第二个参数，如：</p>
<pre><code class="language-haskell">foldr f a xs
</code></pre>
<p>它的结果计算过程为</p>
<pre><code class="language-haskell">&gt; foldr f a [x1, x2, x3]
[1.] a = f x3 a
[2.] a = f x2 a = f x2 (f x3 a)
[3.] a = f x1 a = f x1 (f x2 (f x3 a))
</code></pre>
<p>从中可以看出<span class="heti-skip"><span class="heti-spacing"> </span>f x2 (f x3 a)<span class="heti-spacing"> </span></span>就是<span><span class="heti-spacing"> </span>foldr f a [x2, x3]</span>
因此可以使用递归来写一个和 foldr 效果一样的函数:</p>
<pre><code class="language-haskell">foldr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldr' _ x [] = x
foldr' f a (x:xs) = f x (foldr' f a xs)
</code></pre>
<p>也可以看出，最外层计算时只需要<span class="heti-skip"><span class="heti-spacing"> </span>x1<span class="heti-spacing"> </span></span>并且向下递归，并不会接触到列表末尾，因此可以用于无穷列表。<span>foldr<span class="heti-spacing"> </span></span>即使看上去从右边取值，但是要从左开始展开，可以用于无穷列表</p>
<p>例如：</p>
<pre><code class="language-haskell">ghci&gt; foldr (||) False (repeat True)
True    -- 由于逻辑运算存在短路，计算值全应为True，所以直接返回了
ghci&gt; foldl (||) False (repeat True)
-- 这里什么都不会发生，直到电脑内存被爆掉
-- 因为函数刚开始就需要列表最右侧的值，所以在不断计算这个无穷列表
</code></pre>
<h4 id="scanl_scanr"><span>scanl<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>scanr</span><a class="headerlink" href="#scanl_scanr" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p><span>scan<span class="heti-spacing"> </span></span>类似<span><span class="heti-spacing"> </span>fold</span>，只是将中间得到的每一个值都添加进一个列表中并返回这个列表
scanl 则向右延伸这个列表，scanr 则向左延伸这个列表
但是它和 fold 恰恰相反，scanl 能用于无穷列表，而 scanr 不能</p>
<pre><code class="language-haskell">&gt; scanr f a [x1, x2, x3]
[1.] 最右侧元素(-1 in python) : a
[2.] 右侧第二个元素(-2) : f x3 a
[3.] 右侧第三个元素(-3) : f x2 (f x3 a)
[4.] 右侧第四个元素(-4) : f x1 (f x2 (f x3 a))
</code></pre>
<p>可以看出<span class="heti-skip"><span class="heti-spacing"> </span>f x2 (f x3 a)<span class="heti-spacing"> </span></span>是<span><span class="heti-spacing"> </span>foldr f a [x2, x3]</span>，也是<span class="heti-skip"><span class="heti-spacing"> </span>scanr f a [x2, x3]<span class="heti-spacing"> </span></span>的第一个元素
因此可以用递归来写一个和 scanr 效果一样的函数：</p>
<pre><code class="language-haskell">scanr' :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b]
scanr' _ x [] = [x]
-- scanr' f a (x:xs) = f x (foldr f a xs) : scanr' f a xs
scanr' f a (x:xs) = f x q : qs
                    where qs@(q:_) = scanr' f a xs
</code></pre>
<p><span>scanl<span class="heti-spacing"> </span></span>也是同理：</p>
<pre><code class="language-haskell">scanl' :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b]
scanl' _ x [] = [x]
scanl' f a (x:xs) = a : scanl' f (f a x) xs
</code></pre>
<p>也可以看出，<span>scanr<span class="heti-spacing"> </span></span>返回的列表的第一个元素是最后添加进去的，所以它无法用于无穷列表。而<span class="heti-skip"><span class="heti-spacing"> </span>scanl<span class="heti-spacing"> </span></span>返回的列表中的元素是从左到右依次添加，可以用于无穷列表截取前一部分结果：</p>
<pre><code class="language-haskell">ghci&gt; take 10 (scanl (+) 0 [1..])
[0,1,3,6,10,15,21,28,36,45]
ghci&gt; take 10 (scanr (+) 0 [1..])
[*** Exception: stack overflow
</code></pre>
<h4 id="foldr_foldl">使用<span class="heti-skip"><span class="heti-spacing"> </span>foldr<span class="heti-spacing"> </span></span>编写<span><span class="heti-spacing"> </span>foldl</span><a class="headerlink" href="#foldr_foldl" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p><span>pdcxs<span class="heti-spacing"> </span></span>还给我介绍了一个神奇的操作，用<span class="heti-skip"><span class="heti-spacing"> </span>foldl<span class="heti-spacing"> </span></span>来定义<span><span class="heti-spacing"> </span>foldr</span>：</p>
<pre><code class="language-haskell">foldl' f z xs = foldr (\x g y -&gt; g (f y x)) id xs z
</code></pre>
<p>它利用<span class="heti-skip"><span class="heti-spacing"> </span>foldr (\x g y -&gt; g (f y x)) id xs<span class="heti-spacing"> </span></span>生成一个函数，作用于<span class="heti-skip"><span class="heti-spacing"> </span>z<span class="heti-spacing"> </span></span>得到结果。</p>
<p>先来看一下<span class="heti-skip"><span class="heti-spacing"> </span>foldr<span class="heti-spacing"> </span></span>的类型：</p>
<pre><code class="language-haskell">foldr :: Foldable t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
-- 可以看成 (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
</code></pre>
<p>但是在这个例子中，类型<span class="heti-skip"><span class="heti-spacing"> </span>b<span class="heti-spacing"> </span></span>并不是一个数字，而是一个函数<span><span class="heti-spacing"> </span>(b -&gt; b)</span>。</p>
<p>所以这里<span class="heti-skip"><span class="heti-spacing"> </span>foldr<span class="heti-spacing"> </span></span>的类型可以写成：</p>
<p style="text-align: center;">(a -&gt; (b -&gt; b) -&gt; (b -&gt; b)) -&gt; (b -&gt; b) -&gt; [a] -&gt; (b -&gt; b)</p>
<p>对应于用法<span><span class="heti-spacing"> </span>foldr (\x g y -&gt; g (f y x)) id xs</span> ，它返回的值应该是一个函数，类型为<span><span class="heti-spacing"> </span>b -&gt; b</span>（后面要作用于<span><span class="heti-spacing"> </span>z</span>）
而 xs 对应于 [a]；id 对应于 (b -&gt; b)
所以 (\x g y -&gt; g (f y x)) 要对应于：</p>
<p style="text-align: center;">(a -&gt; (b -&gt; b) -&gt; (b -&gt; b))</p>
<p>因此可以推断出<span class="heti-skip"><span class="heti-spacing"> </span>x<span class="heti-spacing"> </span></span>的类型是<span><span class="heti-spacing"> </span>a</span>；<span>y<span class="heti-spacing"> </span></span>的类型是<span><span class="heti-spacing"> </span>b</span>；而返回的值为一个类型为<span class="heti-skip"><span class="heti-spacing"> </span>(b -&gt; b)<span class="heti-spacing"> </span></span>的函数。</p>
<p>再看，返回的值是<span><span class="heti-spacing"> </span>g (f y x)</span> ，其中<span class="heti-skip"><span class="heti-spacing"> </span>f y x<span class="heti-spacing"> </span></span>返回的是一个值，类型为<span><span class="heti-spacing"> </span>b</span>
所以 g 接收一个类型 b，返回一个类型 b -&gt; b。即 g 的类型为：</p>
<p style="text-align: center;">b -&gt; (b -&gt; b)</p>
<p>现在根据<span class="heti-skip"><span class="heti-spacing"> </span>foldr<span class="heti-spacing"> </span></span>的定义：</p>
<p style="text-align: center;">foldr f a (x:xs) = f x (foldr f a xs)</p>
<p>带入计算一下：</p>
<blockquote>
<p><span>xs<span class="heti-spacing"> </span></span>即为<span><span class="heti-spacing"> </span>[x1..xn]</span>，为了方便，用<span class="heti-skip"><span class="heti-spacing"> </span>xs'<span class="heti-spacing"> </span></span>来表示<span><span class="heti-spacing"> </span>[x2..xn]</span>，用<span class="heti-skip"><span class="heti-spacing"> </span>xs''<span class="heti-spacing"> </span></span>来表示<span><span class="heti-spacing"> </span>[x3..xn]</span></p>
<p>定义中的<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>即为<span><span class="heti-spacing"> </span>(\x g y -&gt; g (f y x))</span>，<span>a<span class="heti-spacing"> </span></span>即为<span><span class="heti-spacing"> </span>id</span></p>
</blockquote>
<pre><code class="language-haskell">  foldr (\x g y -&gt; g (f y x)) id xs z
= (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z
</code></pre>
<p>写完第一步，可以发现，<span>x1 (foldr (...) id xs') z<span class="heti-spacing"> </span></span>正好分别对应了<span class="heti-skip"><span class="heti-spacing"> </span>lambda<span class="heti-spacing"> </span></span>表达式中的<span><span class="heti-spacing"> </span>x</span>、g、y。可以将其应用，进一步展开：</p>
<pre><code class="language-haskell">  (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z
= (foldr (...) id xs') (f z x1)
</code></pre>
<p>不难发现，原式<span class="heti-skip"><span class="heti-spacing"> </span>(foldr (...) id xs) z<span class="heti-spacing"> </span></span>等价于：</p>
<p style="text-align: center;">(foldr (...) id xs') (f z x1)</p>
<p>跟着这个思路，<span>xs<span class="heti-spacing"> </span></span>每次少一个开头的元素<span><span class="heti-spacing"> </span>x'</span>，<span>z<span class="heti-spacing"> </span></span>每次变换成为<span><span class="heti-spacing"> </span>f z x'</span>
因此下一步：</p>
<pre><code class="language-haskell">  (\x g y -&gt; g (f y x)) x1 (foldr (...) id xs') z
= (foldr (...) id xs') (f z x1)
= (foldr (...) id xs'') (f (f z x1) x2)
= (foldr (...) id xs''') (f (f (f z x1) x2) x3)
= ...
</code></pre>
<p>可以发现，已经有了规律。那么最终停止时是什么样呢？</p>
<p>最后到了不能在展开时，最前面的<span class="heti-skip"><span class="heti-spacing"> </span>foldr (...) id xs<span class="heti-spacing"> </span></span>已经变成了<span><span class="heti-spacing"> </span>foldr (...) id []</span>
而根据前面 foldr 的定义 foldr _ x [] = x ，它应该返回 id</p>
<p>所以最后的结果：
(id 的定义：id x = x)</p>
<pre><code class="language-haskell">  ...
= (foldr (...) id xs') (f z x1)
= (foldr (...) id xs'') (f (f z x1) x2)
= ...
= (foldr (...) id []) (f (.. (f z x1) ..) xn)
= id (f (.. (f z x1) ..) xn)
= f (.. (f z x1) ..) xn
</code></pre>
<p>那么最后这个结果就很熟悉了，它就是<span><span class="heti-spacing"> </span>foldl f z xs</span>。
所以我们推导出了这个用 foldr 表示 foldl 的写法是正确的。</p>
<hr/>
<h2 id="modules">Modules<a class="headerlink" href="#modules" title="Permanent link">#</a></h2>
<p><span>Haskell<span class="heti-spacing"> </span></span>会自动加载<span class="heti-skip"><span class="heti-spacing"> </span>Prelude<span class="heti-spacing"> </span></span>模块（module<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，如果在<span class="heti-skip"><span class="heti-spacing"> </span>GHCi<span class="heti-spacing"> </span></span>中再加载其他模块，需要使用 <code>:m + ...</code>，比如加载<span class="heti-skip"><span class="heti-spacing"> </span>Data.List<span class="heti-spacing"> </span></span>模块：</p>
<p style="text-align: center;">Prelude&gt; :m + Data.List</p>
<p>而在<span class="heti-skip"><span class="heti-spacing"> </span>hs<span class="heti-spacing"> </span></span>文件中引入模块，需要使用 <code>import</code> 语句，下面和<span class="heti-skip"><span class="heti-spacing"> </span>python<span class="heti-spacing"> </span></span>的对比可以便于理解：</p>
<pre><code class="language-haskell">import Data.List
-- from Data.List import *

import Data.List (nub, sort)
-- from Data.List import nub, sort

import Data.List hiding (nub)
-- 从Data.List中引入所有，但不引入nub函数

import qualified Data.List
-- import Data.List

import qualified Data.List as Li
-- import Data.List as Li
</code></pre>
<h3 id="modules_1">编写<span><span class="heti-spacing"> </span>Modules</span><a class="headerlink" href="#modules_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<p>模块中要包含将要使用的一些函数，像正常的<span class="heti-skip"><span class="heti-spacing"> </span>hs<span class="heti-spacing"> </span></span>文件一样写即可，但头部需要有导出语句（export<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。比如一个模块文件名叫 <code>ModuleA.hs</code>，那它的头部需要写：</p>
<pre><code class="language-haskell">module ModuleA
( functionA
, functionB
, functionC
) where

</code></pre>
<p>而且文件中的所有函数只导出需要使用的即可。比如该文件中还含有<span class="heti-skip"><span class="heti-spacing"> </span>functionD<span class="heti-spacing"> </span></span>供前三个函数内部使用，那么在<span class="heti-skip"><span class="heti-spacing"> </span>import ModuleA<span class="heti-spacing"> </span></span>之后也无法调用<span><span class="heti-spacing"> </span>functionD</span>。</p>
<hr/>
<h2 id="types_typeclasses">Types &amp; Typeclasses<a class="headerlink" href="#types_typeclasses" title="Permanent link">#</a></h2>
<h3 id="types">Types<a class="headerlink" href="#types" title="Permanent link">#</a></h3>
<p><span>Haskell<span class="heti-spacing"> </span></span>有一个静态类型系统，任何变量、函数都会具有类型，并且有类型判断功能，没给出的类型会自动识别。<br/>
Type 的首字母全为大写，常用的有：</p>
<ul>
<li><code>Int</code>：整型，有上下界范围，-2147483647～2147483648</li>
<li><code>Integer</code>：整数，无界，但是效率比<span class="heti-skip"><span class="heti-spacing"> </span>Int<span class="heti-spacing"> </span></span>低</li>
<li><code>Float</code>：单精度浮点型</li>
<li><code>Double</code>：双精度浮点型</li>
<li><code>Bool</code>：布尔值</li>
<li><code>Char</code>：字符</li>
<li><code>String</code>：字符串，等同于<code>[Char]</code></li>
<li><code>Ordering</code>：大小关系，包含<span><span class="heti-spacing"> </span>LT</span>、EQ、GT，且它们有大小关系<span><span class="heti-spacing"> </span>LT &lt; EQ &lt; GT</span></li>
</ul>
<p>列表的类型是由其中元素决定的，并且列表中元素必须是同一类型，所以列表的类型就是其元素类型外加<code>[]</code>。</p>
<p>元组的类型由其中各个元素的类型共同决定，因为元组中的元素可以是不同类型。如<span class="heti-skip"><span class="heti-spacing"> </span>("abc", 'a', True)<span class="heti-spacing"> </span></span>的类型是<span><span class="heti-spacing"> </span>([Char], Char, Bool)</span>。</p>
<h3 id="typeclasses">Typeclasses<a class="headerlink" href="#typeclasses" title="Permanent link">#</a></h3>
<p>类型类（Typeclass）是定义一系列功能的接口，如果一个<span class="heti-skip"><span class="heti-spacing"> </span>Type<span class="heti-spacing"> </span></span>属于一个<span class="heti-skip"><span class="heti-spacing"> </span>Typeclass<span class="heti-spacing"> </span></span>的成员，那么它可以实现这个类型类所规定的功能。一个<span class="heti-skip"><span class="heti-spacing"> </span>Type<span class="heti-spacing"> </span></span>也可以属于多个<span><span class="heti-spacing"> </span>Typeclass</span><br/>
Typeclass的首字母也全为大写，常见的有：</p>
<ul>
<li><code>Eq</code>：可判断是否相等</li>
<li><code>Ord</code>：可比较大小</li>
<li><code>Show</code>：可展示成字符串</li>
<li><code>Read</code>：可从字符串转换成特定类型</li>
<li><code>Enum</code>：可枚举（连续<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，即可以使用<span class="heti-skip"><span class="heti-spacing"> </span>pred<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>succ<span class="heti-spacing"> </span></span>函数得到前驱和后缀</li>
<li><code>Bounded</code><span>:<span class="heti-spacing"> </span></span>有上下界，如果元组中所有元素都属于<span><span class="heti-spacing"> </span>Bounded</span>，那这个元组的类型也属于<span><span class="heti-spacing"> </span>Bounded</span></li>
<li><code>Integral</code>：是整数，包括<span class="heti-skip"><span class="heti-spacing"> </span>Int<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>Integer</span></li>
<li><code>RealFloat</code>： 是实浮点数，包括<span class="heti-skip"><span class="heti-spacing"> </span>Float<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>Double</span></li>
<li><code>RealFrac</code>：是实分数，包括<span><span class="heti-spacing"> </span>Float</span>、<span>Double<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>Ratio</span>（在<span class="heti-skip"><span class="heti-spacing"> </span>Data.Ratio<span class="heti-spacing"> </span></span>模块中）</li>
<li><code>Floating</code>：是浮点数，包括<span><span class="heti-spacing"> </span>Float</span>、<span>Double<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>Complex</span>（在<span class="heti-skip"><span class="heti-spacing"> </span>Data.Complex<span class="heti-spacing"> </span></span>模块中）</li>
<li><code>Real</code>：是实数，包括<span class="heti-skip"><span class="heti-spacing"> </span>Integral<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>RealFrac<span class="heti-spacing"> </span></span>的成员</li>
<li><code>Fractional</code>：是分数，包括<span class="heti-skip"><span class="heti-spacing"> </span>RealFrac<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>Floating<span class="heti-spacing"> </span></span>的成员</li>
<li><code>Num</code>：是数字，包括上述所有数字相关的类型</li>
</ul>
<h3 id="type_variables">Type variables<a class="headerlink" href="#type_variables" title="Permanent link">#</a></h3>
<p>如果查看一个函数的类型，比如 <code>head</code>，那么将会返回以下类型：</p>
<p style="text-align: center;">head :: [a] -&gt; a</p>
<p>其中的<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>就是一个类型变量（type variable<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，它在<span class="heti-skip"><span class="heti-spacing"> </span>head<span class="heti-spacing"> </span></span>中可以属于任何类型，在这里只是表示返回值的类型和输入的列表中的元素的类型相一致。</p>
<p>在函数的类型表达式其实可以看作<span class="heti-skip"><span class="heti-spacing"> </span>$\lambda$<span class="heti-spacing"> </span></span>表达式，它适用于<span class="heti-skip"><span class="heti-spacing"> </span>$\alpha$<span class="heti-spacing"> </span></span>变换（$\alpha$-conversion<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。即<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>在这里可以指<span><span class="heti-spacing"> </span>Int</span>、<span>Char<span class="heti-spacing"> </span></span>等类型，也可以指<span class="heti-skip"><span class="heti-spacing"> </span>[Char], (Int, Char),<span class="heti-spacing"> </span></span>甚至函数<span class="heti-skip"><span class="heti-spacing"> </span>Int -&gt; Int<span class="heti-spacing"> </span></span>等。</p>
<p>在大部分函数的类型中，类型变量需要保证是某个<span class="heti-skip"><span class="heti-spacing"> </span>Typeclass<span class="heti-spacing"> </span></span>的成员才能完成操作。比如 <code>(==)</code> 函数，它需要传入的参数是可判断相等的，即是<span class="heti-skip"><span class="heti-spacing"> </span>Eq<span class="heti-spacing"> </span></span>的成员，那么 <code>(==)</code> 的类型就是：</p>
<p style="text-align: center;">(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool</p>
<p>其中 <code>=&gt;</code> 前的部分<span class="heti-skip"><span class="heti-spacing"> </span>(Eq a)<span class="heti-spacing"> </span></span>就是类约束（class constraint<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，它规定了<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span>Eq<span class="heti-spacing"> </span></span>的成员，所以 <code>(==)</code> 函数传入的两个参数都是<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>类型，且都是<span class="heti-skip"><span class="heti-spacing"> </span>Eq<span class="heti-spacing"> </span></span>的成员，保证了它们之间是可以比较是否相等的。</p>
<h3 id="type">定义新<span><span class="heti-spacing"> </span>Type</span><a class="headerlink" href="#type" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<p>定义一个新的<span class="heti-skip"><span class="heti-spacing"> </span>Type<span class="heti-spacing"> </span></span>需要使用 <code>data</code> 关键字，比如定义 <code>Bool</code> 需要使用：</p>
<p style="text-align: center;">data Bool = False | True</p>
<p>其中<span class="heti-skip"><span class="heti-spacing"> </span>=<span class="heti-spacing"> </span></span>左侧的部分定义了新类型的名称 <code>Bool</code>，右侧的部分叫做值构造器（value constructors<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，表示了<span class="heti-skip"><span class="heti-spacing"> </span>Bool<span class="heti-spacing"> </span></span>类型的值为<span class="heti-skip"><span class="heti-spacing"> </span>False<span class="heti-spacing"> </span></span>或<span><span class="heti-spacing"> </span>True</span>。<br/>
并且名称和值构造器的首字母都需要大写。</p>
<p>另外，值构造器也是函数，它们可以有参数，叫做项（field<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。比如：</p>
<pre><code class="language-haskell">data Shape = Circle Float Float Float | Rectangle Float Float Float Float   
</code></pre>
<p>它定义了一个新<span class="heti-skip"><span class="heti-spacing"> </span>Type<span class="heti-spacing"> </span></span>叫<span><span class="heti-spacing"> </span>Shape</span>，值构造器是<span class="heti-skip"><span class="heti-spacing"> </span>Circle<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>Rectangle</span>，<span>Circle<span class="heti-spacing"> </span></span>接收三个参数都是<span class="heti-skip"><span class="heti-spacing"> </span>Float<span class="heti-spacing"> </span></span>类型，<span>Rectangle<span class="heti-spacing"> </span></span>接收四个<span class="heti-skip"><span class="heti-spacing"> </span>Float<span class="heti-spacing"> </span></span>类型参数。<br/>
如果查看 Circle 的类型，将返回：</p>
<p style="text-align: center;">Circle :: Float -&gt; Float -&gt; Float -&gt; Shape</p>
<p>如果想要让它能给直接显示出来，需要让它属于<span class="heti-skip"><span class="heti-spacing"> </span>Show<span class="heti-spacing"> </span></span>类型类。在代码中只需要在结尾加上<code>deriving (Show)</code><span><span class="heti-spacing"> </span>:</span></p>
<pre><code class="language-haskell">data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)
</code></pre>
<p>类型的名称和值构造器名称也可以相同，比如：</p>
<pre><code class="language-haskell">data Point = Point Float Float deriving (Show)
</code></pre>
<h4 id="type_1">导出<span><span class="heti-spacing"> </span>Type</span><a class="headerlink" href="#type_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p>在文件中定义了新的<span class="heti-skip"><span class="heti-spacing"> </span>Type<span class="heti-spacing"> </span></span>之后，如果在别的文件中将其作为模块导入，则需要先导出。比如文件 <code>Shapes.hs</code> 中定义了<span class="heti-skip"><span class="heti-spacing"> </span>Shape<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>Point</span>，以及其他的一些函数，那么文件开头需要写：</p>
<pre><code class="language-haskell">module Shapes
( Shape(..)
, Point(..)
, functionA
, functionB
) where
</code></pre>
<p>其中的 <code>Shape(..)</code> 导出了<span class="heti-skip"><span class="heti-spacing"> </span>Shape<span class="heti-spacing"> </span></span>类型和它所有的值构造器，<code>..</code> 代表了它的所有值构造器。因此，<code>Shape(..)</code> 相当于 <code>Shape (Circle, Rectangle)</code>。</p>
<p>如果不想要导出值构造器，即不允许使用值构造器的方法来创建<span class="heti-skip"><span class="heti-spacing"> </span>Shape<span class="heti-spacing"> </span></span>类型的变量。那么需要将 <code>Shape(..)</code> 替换为 <code>Shape</code>，这样就只导出了<span class="heti-skip"><span class="heti-spacing"> </span>Shape<span class="heti-spacing"> </span></span>类型，而不导出其值构造器。</p>
<h4 id="record_syntax">Record Syntax<a class="headerlink" href="#record_syntax" title="Permanent link">#</a></h4>
<p>如果想要方便地取出类型实例中的参数，可以使用<span class="heti-skip"><span class="heti-spacing"> </span>Record<span class="heti-spacing"> </span></span>语法，如：</p>
<pre><code class="language-haskell">data Point = Point { xcoord :: Float
                   , ycoord :: Float
                   } deriving (Show)
</code></pre>
<p>在值构造器的参数部分先加一个大括号，然后指定取出值的函数名称（xcoord, ycoord<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，后面指定类型（:: Float<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。这样<span class="heti-skip"><span class="heti-spacing"> </span>xcoord<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>ycoord<span class="heti-spacing"> </span></span>就都是一个类型为<span class="heti-skip"><span class="heti-spacing"> </span>Point -&gt; Float<span class="heti-spacing"> </span></span>的函数，可以通过下面方法来访问值：</p>
<pre><code class="language-haskell">ghci&gt; let point = Point 1.0 2.0
ghci&gt; xcoord point
1.0
ghci&gt; ycoord point
2.0
</code></pre>
<p>同时也可以通过下面方法来创建这个<span><span class="heti-spacing"> </span>point</span>：</p>
<pre><code class="language-haskell">point = Point {ycoord=2.0, xcoord=1.0}
</code></pre>
<h4 id="type_parameters">Type parameters<a class="headerlink" href="#type_parameters" title="Permanent link">#</a></h4>
<p>值构造器可以接收参数，类型也可以接收参数，这样它就成为了类型构造器（type constructors<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。如<span class="heti-skip"><span class="heti-spacing"> </span>Maybe<span class="heti-spacing"> </span></span>的定义：</p>
<p style="text-align: center;">data Maybe a = Nothing | Just a</p>
<p>它的值是<span class="heti-skip"><span class="heti-spacing"> </span>Nothing<span class="heti-spacing"> </span></span>时，类型为<span><span class="heti-spacing"> </span>Maybe a</span>，是多态的（polymorphic<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。<br/>
它的值不是 Nothing 时，类型取决于值 Just a 中 a 的类型，可以构造出 Maybe Int、Maybe [Char] 等多种类型：</p>
<pre><code class="language-haskell">Nothing :: Maybe a
Just 1 :: Num a =&gt; Maybe a
Just 'a' :: Maybe Char
Just "abc" :: Maybe [Char]
</code></pre>
<p>可以用这种方法改写<span><span class="heti-spacing"> </span>Point</span>：</p>
<pre><code class="language-haskell">data Point x y = Point { xcoord :: x
                       , ycoord :: y
                       } deriving (Show)
</code></pre>
<p>但使用类型参数（type parameters）并不是总是方便，比如在声明函数类型的时候不能只使用<span class="heti-skip"><span class="heti-spacing"> </span>Point<span class="heti-spacing"> </span></span>来表示<span class="heti-skip"><span class="heti-spacing"> </span>Point<span class="heti-spacing"> </span></span>类型，而是必须写成<span><span class="heti-spacing"> </span>Point Float Float</span>。</p>
<p>而且不能在定义类型构造器时添加类约束（class constraint<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，不然在之后声明函数类型的时候也都需要添加类约束，如：</p>
<pre><code class="language-haskell">data (Ord k) =&gt; Map k v = ... 
toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)]
</code></pre>
<h4 id="either">Either<a class="headerlink" href="#either" title="Permanent link">#</a></h4>
<p><span>Either<span class="heti-spacing"> </span></span>是一个类型构造器，它有两个值构造器，定义是：</p>
<pre><code class="language-haskell">data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)  
</code></pre>
<p>如果使用了<span><span class="heti-spacing"> </span>Left</span>，那它的<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>的类型就是具体的；如果使用了<span><span class="heti-spacing"> </span>Right</span>，那它的<span class="heti-skip"><span class="heti-spacing"> </span>b<span class="heti-spacing"> </span></span>的类型就是具体的：</p>
<pre><code class="language-haskell">ghci&gt; Right 20  
Right 20  
ghci&gt; Left "w00t"  
Left "w00t"  
ghci&gt; :t Right 'a'  
Right 'a' :: Either a Char  
ghci&gt; :t Left True  
Left True :: Either Bool b  
</code></pre>
<p><span>Either<span class="heti-spacing"> </span></span>可以看作<span class="heti-skip"><span class="heti-spacing"> </span>Maybe<span class="heti-spacing"> </span></span>的补充，比如<span class="heti-skip"><span class="heti-spacing"> </span>Maybe<span class="heti-spacing"> </span></span>在使用时，出现异常可以返回<span><span class="heti-spacing"> </span>Nothing</span>，但只是一个<span><span class="heti-spacing"> </span>Nothing</span>，不包含任何信息；但<span class="heti-skip"><span class="heti-spacing"> </span>Either<span class="heti-spacing"> </span></span>包含左值和右值，正常结果返回右值，而出现异常就可以返回包含错误信息的左值，比如安全除法：</p>
<pre><code class="language-haskell">safeDiv :: Int -&gt; Int -&gt; Maybe Int
safeDiv _ 0 = Nothing
safeDiv x y = Just (x `div` y)

ghci&gt; safeDiv 4 2
Just 2
ghci&gt; safeDiv 1 0
Nothing
</code></pre>
<p>而使用<span><span class="heti-spacing"> </span>Either</span>：</p>
<pre><code class="language-haskell">safeDiv :: Int -&gt; Int -&gt; Either String Int
safeDiv _ 0 = Left "Divided by zero"
safeDiv x y = Right (x `div` y)

ghci&gt; safeDiv 4 2
Right 2
ghci&gt; safeDiv 1 0
Left "Divided by zero"
</code></pre>
<h4 id="derived_instances">Derived instances<a class="headerlink" href="#derived_instances" title="Permanent link">#</a></h4>
<p>想要使一个定义的类满足某些<span class="heti-skip"><span class="heti-spacing"> </span>Typeclass<span class="heti-spacing"> </span></span>的需求，需要从其派生（derive<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，比如：</p>
<pre><code class="language-haskell">data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday   
           deriving (Eq, Ord, Show, Read, Bounded, Enum)  
</code></pre>
<p>这样<span class="heti-skip"><span class="heti-spacing"> </span>Day<span class="heti-spacing"> </span></span>类型的值（Monday～Sunday）之间就可以比较是否相等（从<span class="heti-skip"><span class="heti-spacing"> </span>Eq<span class="heti-spacing"> </span></span>派生<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，比较大小（从<span class="heti-skip"><span class="heti-spacing"> </span>Ord<span class="heti-spacing"> </span></span>派生，左侧为小，右侧为大<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，显示成字符串（从<span class="heti-skip"><span class="heti-spacing"> </span>Show<span class="heti-spacing"> </span></span>派生<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，从字符串中读取（从<span class="heti-skip"><span class="heti-spacing"> </span>Read<span class="heti-spacing"> </span></span>派生<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，包含边界（从<span class="heti-skip"><span class="heti-spacing"> </span>Bounded<span class="heti-spacing"> </span></span>派生<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，可以枚举（从<span class="heti-skip"><span class="heti-spacing"> </span>Enum<span class="heti-spacing"> </span></span>派生，按照值构造器中的顺序依次向右）</p>
<h4 id="type_synonyms">Type synonyms<a class="headerlink" href="#type_synonyms" title="Permanent link">#</a></h4>
<p>为了阅读方便，书写简便，可以使用 <code>type</code> 关键字为已有类型创建别名（synonyms<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。比如<span class="heti-skip"><span class="heti-spacing"> </span>String<span class="heti-spacing"> </span></span>的定义：</p>
<p style="text-align: center;">type String = [Char]</p>
<p>在所有需要使用字符串（即<span><span class="heti-spacing"> </span>[Char]</span>）的地方都可以使用<span class="heti-skip"><span class="heti-spacing"> </span>String<span class="heti-spacing"> </span></span>来代替，它们是完全一致的，只是<span class="heti-skip"><span class="heti-spacing"> </span>String<span class="heti-spacing"> </span></span>更简便易读。<br/>
同时，类型别名也可以接收类型参数</p>
<h4 id="newtype_keyword">newtype keyword<a class="headerlink" href="#newtype_keyword" title="Permanent link">#</a></h4>
<p>除了 <code>data</code>、<code>type</code> 关键字之外，还可以用 <code>newtype</code> 关键字来定义一个新的类型，比如 <code>Control.Applicative</code> 模块中的<span><span class="heti-spacing"> </span>ZipList</span>：</p>
<pre><code class="language-haskell">newtype ZipList a = { getZipList :: [a] }
</code></pre>
<ul>
<li>不同于<span><span class="heti-spacing"> </span>type</span>，它不是别名，可以使用<span class="heti-skip"><span class="heti-spacing"> </span>record<span class="heti-spacing"> </span></span>语法来直接定义取出值的函数</li>
<li>不同于<span><span class="heti-spacing"> </span>data</span>，它只能有一个值构造器，但是速度要比<span class="heti-skip"><span class="heti-spacing"> </span>data<span class="heti-spacing"> </span></span>快，而且更加懒惰</li>
</ul>
<h4 id="recursive_data_structures">Recursive data structures<a class="headerlink" href="#recursive_data_structures" title="Permanent link">#</a></h4>
<p>一个类型也可以递归定义，比如一颗二叉树：</p>
<pre><code class="language-haskell">data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)  
</code></pre>
<h3 id="typeclass">定义新<span><span class="heti-spacing"> </span>Typeclass</span><a class="headerlink" href="#typeclass" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<p>定义一个新的<span class="heti-skip"><span class="heti-spacing"> </span>Typeclass<span class="heti-spacing"> </span></span>需要使用<span class="heti-skip"><span class="heti-spacing"> </span>class<span class="heti-spacing"> </span></span>关键字，例如定义<span class="heti-skip"><span class="heti-spacing"> </span>Eq<span class="heti-spacing"> </span></span>类型类：</p>
<pre><code class="language-haskell">class Eq a where  
    (==) :: a -&gt; a -&gt; Bool  
    (/=) :: a -&gt; a -&gt; Bool  
    x == y = not (x /= y)  
    x /= y = not (x == y)  
</code></pre>
<p>其中 <code>a</code> 是一个类型变量，前两行声明了需要实现的函数的名字及其类型，后两行表明了需要的函数之间可以相互定义（不必要<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<p>包含了后两行之后，只定义<span class="heti-skip"><span class="heti-spacing"> </span>(==)<span class="heti-spacing"> </span></span>函数或者<span class="heti-skip"><span class="heti-spacing"> </span>(/=)<span class="heti-spacing"> </span></span>函数都可以完成全部定义，它们（<code>(==) | (/=)</code>）成为这个类型类的最小完整定义（minimal complete definition）</p>
<p>查看一个类型类的成员需要实现的函数可以在<span class="heti-skip"><span class="heti-spacing"> </span>GHCi<span class="heti-spacing"> </span></span>中使用 <code>:info</code>：</p>
<p style="text-align: center;">ghci&gt; :info Eq</p>
<h4 id="_4">手动创建实例<a class="headerlink" href="#_4" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p>使一个类型成为一个类型类的实例可以直接使用 <code>deriving</code> 来自动完成，也可以通过使用<span class="heti-skip"><span class="heti-spacing"> </span>instance<span class="heti-spacing"> </span></span>关键字来手动完成。比如使<span class="heti-skip"><span class="heti-spacing"> </span>Point<span class="heti-spacing"> </span></span>成为<span class="heti-skip"><span class="heti-spacing"> </span>Show<span class="heti-spacing"> </span></span>的实例：</p>
<pre><code class="language-haskell">instance Show Point where
    show (Point x y) = "(" ++ show x ++ ", " ++ show y ++ ")"

-- in ghci
ghci&gt; Point 1.0 2.0
(1.0, 2.0)
</code></pre>
<p>这样就可以自定义显示的内容，否则使用<span class="heti-skip"><span class="heti-spacing"> </span>deriving<span class="heti-spacing"> </span></span>的话只会直接将其转化为字符串。</p>
<p>同时也要注意类型和类型构造器的区别，传入给<span class="heti-skip"><span class="heti-spacing"> </span>instance<span class="heti-spacing"> </span></span>的第二个参数应该为类型而不是类型构造器，比如<span><span class="heti-spacing"> </span>Maybe</span>：</p>
<pre><code class="language-haskell">instance Eq Maybe where  
    ...    
-- 错误用法，因为Maybe是类型构造器而不是类型

instance Eq (Maybe m) where  
    ...
-- 错误用法，因为m不一定是Eq的成员

instance (Eq m) =&gt; Eq (Maybe m) where  
    Just x == Just y = x == y  
    Nothing == Nothing = True  
    _ == _ = False  
</code></pre>
<h4 id="functor_typeclass">Functor Typeclass<a class="headerlink" href="#functor_typeclass" title="Permanent link">#</a></h4>
<p><span>Functor<span class="heti-spacing"> </span></span>也是一种类型类，它只规定了一个函数：</p>
<pre><code class="language-haskell">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>其中 <code>f</code> 是一个类型构造器，而不是一个具体类型</p>
<h3 id="kinds">Kinds<a class="headerlink" href="#kinds" title="Permanent link">#</a></h3>
<p>一个值的类型叫做类型（Type<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，而一个类型的类型叫做<span><span class="heti-spacing"> </span>Kind</span>。可以通过<span class="heti-skip"><span class="heti-spacing"> </span>GHCi<span class="heti-spacing"> </span></span>中 <code>:k</code> 来查看<span><span class="heti-spacing"> </span>Kind</span>：</p>
<pre><code class="language-haskell">ghci&gt; :k Int
Int :: *
ghci&gt; :k Maybe
Maybe :: * -&gt; *
ghci&gt; :k Maybe Int
Maybe Int :: *
ghci&gt; :k Either
Either :: * -&gt; * -&gt; *
</code></pre>
<p>其中的星号 <code>*</code> 代表了一个具体类型（concrete type<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。<span>Int<span class="heti-spacing"> </span></span>本身就是一个具体类型，所以<span class="heti-skip"><span class="heti-spacing"> </span>Int<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>Kind<span class="heti-spacing"> </span></span>是<span><span class="heti-spacing"> </span>*</span>。而<span class="heti-skip"><span class="heti-spacing"> </span>Maybe<span class="heti-spacing"> </span></span>是一个类型构造器，它接收一个具体类型返回一个新的具体类型，所以<span class="heti-skip"><span class="heti-spacing"> </span>Maybe<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>Kind<span class="heti-spacing"> </span></span>是<span><span class="heti-spacing"> </span>* -&gt; *</span>。如果给<span class="heti-skip"><span class="heti-spacing"> </span>Maybe<span class="heti-spacing"> </span></span>传入了一个<span><span class="heti-spacing"> </span>Int</span>，那么得到的<span class="heti-skip"><span class="heti-spacing"> </span>Maybe Int<span class="heti-spacing"> </span></span>就是一个具体的类型，它的<span class="heti-skip"><span class="heti-spacing"> </span>Kind<span class="heti-spacing"> </span></span>就是<span><span class="heti-spacing"> </span>*</span>。<span>Either<span class="heti-spacing"> </span></span>也是一个类型构造器，但它接收两个类型才产生一个新的类型，所以<span class="heti-skip"><span class="heti-spacing"> </span>Either<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>Kind<span class="heti-spacing"> </span></span>是<span><span class="heti-spacing"> </span>* -&gt; * -&gt; *</span>。</p>
<hr/>
<h2 id="inputoutput">Input/Output<a class="headerlink" href="#inputoutput" title="Permanent link">#</a></h2>
<h3 id="haskell">运行<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>程序<a class="headerlink" href="#haskell" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<p>不在<span class="heti-skip"><span class="heti-spacing"> </span>GHCi<span class="heti-spacing"> </span></span>中运行一个<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>程序有两种方式：</p>
<ol>
<li>编译运行：
    <code>sh
    $ ghc --make code
    $ ./code</code></li>
<li>通过 <code>runhaskell</code> 命令直接运行：
    <code>sh
    $ runhaskell code.hs</code></li>
</ol>
<h3 id="_5">输出文本<a class="headerlink" href="#_5" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<p>在一个<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>程序中输出文字需要定义一个<span class="heti-skip"><span class="heti-spacing"> </span>main<span class="heti-spacing"> </span></span>函数：</p>
<pre><code class="language-haskell">main = putStrLn "Hello World"
</code></pre>
<p>其中<span class="heti-skip"><span class="heti-spacing"> </span>putStrLn<span class="heti-spacing"> </span></span>的类型是：</p>
<p style="text-align: center;">putStrLn :: String -&gt; IO ()</p>
<p><span>putStrLn<span class="heti-spacing"> </span></span>接收一个<span class="heti-skip"><span class="heti-spacing"> </span>String<span class="heti-spacing"> </span></span>类型，并返回一个结果为<span class="heti-skip"><span class="heti-spacing"> </span>()<span class="heti-spacing"> </span></span>类型的<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>动作（I/O action<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。所以<span class="heti-skip"><span class="heti-spacing"> </span>main<span class="heti-spacing"> </span></span>函数的类型为<span><span class="heti-spacing"> </span>IO ()</span><heti-adjacent class="heti-adjacent-half">。</heti-adjacent>（<span>IO<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>Kind<span class="heti-spacing"> </span></span>是<span><span class="heti-spacing"> </span>* -&gt; *</span>）</p>
<p>除此之外，还有其他默认提供的输出文本的函数：</p>
<ul>
<li><code>putStr</code>：输出文本，结尾不换行</li>
<li><code>putChar</code>：输出单个字符，结尾不换行。接收的参数为单个<span><span class="heti-spacing"> </span>Char</span>，不是<span><span class="heti-spacing"> </span>String</span>（用单引号不是双引号）</li>
<li><code>print</code>：可以接收任何<span class="heti-skip"><span class="heti-spacing"> </span>Show<span class="heti-spacing"> </span></span>的成员，先用<span class="heti-skip"><span class="heti-spacing"> </span>show<span class="heti-spacing"> </span></span>转化为字符串然后输出。等同于<span><span class="heti-spacing"> </span>putStrLn . show</span></li>
</ul>
<h4 id="do_block">do block<a class="headerlink" href="#do_block" title="Permanent link">#</a></h4>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span>main<span class="heti-spacing"> </span></span>函数中使用多个<span class="heti-skip"><span class="heti-spacing"> </span>putStrLn<span class="heti-spacing"> </span></span>需要使用<span class="heti-skip"><span class="heti-spacing"> </span>do<span class="heti-spacing"> </span></span>语句：</p>
<pre><code class="language-haskell">main = do
    putStrLn "Line1"
    putStrLn "Line2"
</code></pre>
<p>其中最后一行一定要返回<span class="heti-skip"><span class="heti-spacing"> </span>IO ()<span class="heti-spacing"> </span></span>类型的值</p>
<h3 id="_6">输入文本<a class="headerlink" href="#_6" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<p>输入文字需要在<span class="heti-skip"><span class="heti-spacing"> </span>do<span class="heti-spacing"> </span></span>块中使用<span><span class="heti-spacing"> </span>getLine</span>：</p>
<pre><code class="language-haskell">main = do
    line &lt;- getLine
    putStrLn line
</code></pre>
<p><span>getLine<span class="heti-spacing"> </span></span>的类型是：</p>
<p style="text-align: center;">getLine :: IO String</p>
<p>而<span class="heti-skip"><span class="heti-spacing"> </span>&lt;-<span class="heti-spacing"> </span></span>操作符将<span class="heti-skip"><span class="heti-spacing"> </span>getLine<span class="heti-spacing"> </span></span>中的<span class="heti-skip"><span class="heti-spacing"> </span>String<span class="heti-spacing"> </span></span>提取了出来给到了<span><span class="heti-spacing"> </span>line</span>，使<span class="heti-skip"><span class="heti-spacing"> </span>line<span class="heti-spacing"> </span></span>变成了<span class="heti-skip"><span class="heti-spacing"> </span>String<span class="heti-spacing"> </span></span>类型的一个字符串</p>
<p>而且使用输入的字符串必须要经过一次<span><span class="heti-spacing"> </span>&lt;-</span>，不能直接使用<span class="heti-skip"><span class="heti-spacing"> </span>getLine<span class="heti-spacing"> </span></span>作为字符串，因为<span class="heti-skip"><span class="heti-spacing"> </span>getLine<span class="heti-spacing"> </span></span>不是<span class="heti-skip"><span class="heti-spacing"> </span>String<span class="heti-spacing"> </span></span>类型，而是<span class="heti-skip"><span class="heti-spacing"> </span>IO String<span class="heti-spacing"> </span></span>类型</p>
<p>除此之外，还可以使用<span class="heti-skip"><span class="heti-spacing"> </span>getChar<span class="heti-spacing"> </span></span>来获取单个字符，但仍然需要使用<span class="heti-skip"><span class="heti-spacing"> </span>&lt;-<span class="heti-spacing"> </span></span>操作符来提取<span><span class="heti-spacing"> </span>Char</span></p>
<h3 id="io">其他<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>相关函数用法<a class="headerlink" href="#io" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<h4 id="return">return<a class="headerlink" href="#return" title="Permanent link">#</a></h4>
<p><span>Haskell<span class="heti-spacing"> </span></span>中的<span class="heti-skip"><span class="heti-spacing"> </span>return<span class="heti-spacing"> </span></span>和其他命令式语言中的<span class="heti-skip"><span class="heti-spacing"> </span>return<span class="heti-spacing"> </span></span>完全不同，它不会使函数直接结束并返回一个值。</p>
<p><span>main<span class="heti-spacing"> </span></span>函数必须定义为类型为<span class="heti-skip"><span class="heti-spacing"> </span>IO ()<span class="heti-spacing"> </span></span>的函数，所以在<span class="heti-skip"><span class="heti-spacing"> </span>main<span class="heti-spacing"> </span></span>函数中使用<span class="heti-skip"><span class="heti-spacing"> </span>if<span class="heti-spacing"> </span></span>语句，如果不输出的话也不可以直接放下什么都不干，因为这时候<span class="heti-skip"><span class="heti-spacing"> </span>main<span class="heti-spacing"> </span></span>函数的类型不是<span><span class="heti-spacing"> </span>IO ()</span>。所以这时需要使用<span class="heti-skip"><span class="heti-spacing"> </span>return ()<span class="heti-spacing"> </span></span>来为<span class="heti-skip"><span class="heti-spacing"> </span>main<span class="heti-spacing"> </span></span>函数指定为<span class="heti-skip"><span class="heti-spacing"> </span>IO ()<span class="heti-spacing"> </span></span>类型，例如：</p>
<pre><code class="language-haskell">main = do 
    line &lt;- getLine
    if null line
        then return () -- &lt;-这里
        else do
            ...
</code></pre>
<p>使用<span class="heti-skip"><span class="heti-spacing"> </span>&lt;-<span class="heti-spacing"> </span></span>操作符也可以直接将<span class="heti-skip"><span class="heti-spacing"> </span>return<span class="heti-spacing"> </span></span>语句中的内容提取出来，比如<span><span class="heti-spacing"> </span>a &lt;- return 'A'</span>，执行后<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>就是<span><span class="heti-spacing"> </span>'A'</span>。</p>
<h4 id="when">when<a class="headerlink" href="#when" title="Permanent link">#</a></h4>
<p><span>when<span class="heti-spacing"> </span></span>包含在 <code>Control.Monad</code> 模块中，它表示在满足第一个参数的条件下会执行第二个函数，否则会<span><span class="heti-spacing"> </span>return ()</span>。比如：</p>
<pre><code class="language-haskell">import Control.Monad   

main = do  
    c &lt;- getChar  
    when (c /= ' ') $ do  
        putChar c  
        main  
</code></pre>
<p>等同于：</p>
<pre><code class="language-haskell">main = do     
    c &lt;- getChar  
    if c /= ' '  
        then do  
            putChar c  
            main  
        else return () 
</code></pre>
<h4 id="sequence">sequence<a class="headerlink" href="#sequence" title="Permanent link">#</a></h4>
<p><span>sequence<span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>中使用时可以达成<span class="heti-skip"><span class="heti-spacing"> </span>[IO a] -&gt; IO [a]<span class="heti-spacing"> </span></span>的效果，所以可以用作：</p>
<pre><code class="language-haskell">[a, b, c] &lt;- sequence [getLine, getLine, getLine]
</code></pre>
<h4 id="mapm_mapm_">mapM &amp; mapM_<a class="headerlink" href="#mapm_mapm_" title="Permanent link">#</a></h4>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>相关的地方使用<span><span class="heti-spacing"> </span>map</span>，可以使用<span class="heti-skip"><span class="heti-spacing"> </span>mapM<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>mapM_</span>，其中<span class="heti-skip"><span class="heti-spacing"> </span>mapM<span class="heti-spacing"> </span></span>有返回值而<span class="heti-skip"><span class="heti-spacing"> </span>mapM_<span class="heti-spacing"> </span></span>直接扔掉了返回值：</p>
<pre><code class="language-haskell">ghci&gt; mapM print [1,2,3]  
1  
2  
3  
[(),(),()]  
ghci&gt; mapM_ print [1,2,3]  
1  
2  
3  
</code></pre>
<h4 id="forever">forever<a class="headerlink" href="#forever" title="Permanent link">#</a></h4>
<p><span>forever<span class="heti-spacing"> </span></span>函数包含在 <code>Control.Monad</code> 模块中。在<span class="heti-skip"><span class="heti-spacing"> </span>main<span class="heti-spacing"> </span></span>函数开头加上<span class="heti-skip"><span class="heti-spacing"> </span>forever<span class="heti-spacing"> </span></span>函数可以使后面的<span class="heti-skip"><span class="heti-spacing"> </span>do<span class="heti-spacing"> </span></span>块一直重复执行直到程序被迫终止，如：</p>
<pre><code class="language-haskell">import Control.Monad

main = forever $ do
    ...
</code></pre>
<h4 id="form">forM<a class="headerlink" href="#form" title="Permanent link">#</a></h4>
<p><span>forM<span class="heti-spacing"> </span></span>函数包含在 <code>Control.Monad</code> 模块中，它的功能和<span class="heti-skip"><span class="heti-spacing"> </span>mapM<span class="heti-spacing"> </span></span>类似，从第一个参数中逐个取出元素传入第二个参数（一个接收一个参数的函数）中，并且第二个参数可以返回<span class="heti-skip"><span class="heti-spacing"> </span>IO a<span class="heti-spacing"> </span></span>类型。比如：</p>
<pre><code class="language-haskell">import Control.Monad

main = do 
    colors &lt;- forM [1, 2, 3, 4] (\a -&gt; do
        putStrLn $ "Which color do you associate with the number " ++ show a ++ "?"  
        color &lt;- getLine  
        return color)
    putStrLn "The colors that you associate with 1, 2, 3 and 4 are: "  
    mapM putStrLn colors
</code></pre>
<h4 id="getcontents">getContents<a class="headerlink" href="#getcontents" title="Permanent link">#</a></h4>
<p><span>getLine<span class="heti-spacing"> </span></span>获取一整行，而<span class="heti-skip"><span class="heti-spacing"> </span>getContents<span class="heti-spacing"> </span></span>从标准输入中获取全部内容直到遇到<span><span class="heti-spacing"> </span>EOF</span>，并且它是<span class="heti-skip"><span class="heti-spacing"> </span>lazy<span class="heti-spacing"> </span></span>的，在执行了<span class="heti-skip"><span class="heti-spacing"> </span>foo &lt;- getContents<span class="heti-spacing"> </span></span>后，它并不会读取标准输入并且赋值到<span><span class="heti-spacing"> </span>foo</span>，而是等到需要使用<span class="heti-skip"><span class="heti-spacing"> </span>foo<span class="heti-spacing"> </span></span>的时候再从标准输入读取。</p>
<p><span>getContents<span class="heti-spacing"> </span></span>在使用管道传入文字时很常用，可以代替<span class="heti-skip"><span class="heti-spacing"> </span>forever+getLine<span class="heti-spacing"> </span></span>使用，比如一个<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>程序文件<span><span class="heti-spacing"> </span>code.hs</span>：</p>
<pre><code class="language-haskell">import Data.Char  

main = do  
    contents &lt;- getContents  
    putStr (map toUpper contents)  
</code></pre>
<p>使用<span class="heti-skip"><span class="heti-spacing"> </span>ghc --make code<span class="heti-spacing"> </span></span>编译后，通过管道传入文字：</p>
<pre><code class="language-sh">cat text.txt | ./code
</code></pre>
<p>会将<span class="heti-skip"><span class="heti-spacing"> </span>text.txt<span class="heti-spacing"> </span></span>中的所有字母转为大写并输出</p>
<h4 id="interact">interact<a class="headerlink" href="#interact" title="Permanent link">#</a></h4>
<p>上述功能还可以转化为一个<span class="heti-skip"><span class="heti-spacing"> </span>String -&gt; String<span class="heti-spacing"> </span></span>的函数：</p>
<pre><code class="language-haskell">upperStrings = unlines . map (map toUpper) . lines
</code></pre>
<p>而在<span class="heti-skip"><span class="heti-spacing"> </span>main<span class="heti-spacing"> </span></span>中使用这个函数就需要：</p>
<pre><code class="language-haskell">main = do
    contents &lt;- getContents
    putStr (upperStrings contents)
</code></pre>
<p>但是<span class="heti-skip"><span class="heti-spacing"> </span>String -&gt; String<span class="heti-spacing"> </span></span>类型的函数在输入输出中的使用太常见了，所以可以使用<span class="heti-skip"><span class="heti-spacing"> </span>interact<span class="heti-spacing"> </span></span>函数来简化。<span>interact<span class="heti-spacing"> </span></span>的类型是：</p>
<p style="text-align: center;">interact :: (String -&gt; String) -&gt; IO ()</p>
<p>可以看出它接收一个<span class="heti-skip"><span class="heti-spacing"> </span>String -&gt; String<span class="heti-spacing"> </span></span>的函数，并返回一个<span class="heti-skip"><span class="heti-spacing"> </span>IO ()<span class="heti-spacing"> </span></span>类型，所以可以直接用在<span class="heti-skip"><span class="heti-spacing"> </span>main<span class="heti-spacing"> </span></span>上。</p>
<p>于是整个转换为大写的程序就可以简化为：</p>
<pre><code class="language-haskell">main = interact $ unlines . map (map toUpper) . lines
</code></pre>
<h3 id="_7">文件和流<a class="headerlink" href="#_7" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<p>以下与文件和流相关的函数都包含在 <code>System.IO</code> 模块中</p>
<h4 id="openfile">openFile<a class="headerlink" href="#openfile" title="Permanent link">#</a></h4>
<p><span>openFile<span class="heti-spacing"> </span></span>函数可以用来打开一个文件，它的类型是：</p>
<p style="text-align: center;">openFile :: FilePath -&gt; IOMode -&gt; IO Handle</p>
<p>其中 <code>FilePath</code> 是<span class="heti-skip"><span class="heti-spacing"> </span>String<span class="heti-spacing"> </span></span>的<span><span class="heti-spacing"> </span>type synonyms</span>，用一个字符串来表示需要打开的文件的路径</p>
<p><code>IOMode</code>的定义是：</p>
<pre><code class="language-haskell">data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
</code></pre>
<p>所以它一共只有四个值，用来表示进行<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>操作的模式</p>
<p><span>openFile<span class="heti-spacing"> </span></span>返回一个<span class="heti-skip"><span class="heti-spacing"> </span>IO Handle<span class="heti-spacing"> </span></span>类型的值，将其用<span class="heti-skip"><span class="heti-spacing"> </span>&lt;-<span class="heti-spacing"> </span></span>操作符提取后会出现一个<span class="heti-skip"><span class="heti-spacing"> </span>Handle<span class="heti-spacing"> </span></span>的值。但不能从<span class="heti-skip"><span class="heti-spacing"> </span>Handle<span class="heti-spacing"> </span></span>中直接使用文字，还需要使用一系列函数：</p>
<ul>
<li><code>hGetContents</code> :: Handle -&gt; IO String ，从<span class="heti-skip"><span class="heti-spacing"> </span>Handle<span class="heti-spacing"> </span></span>中读取全部内容，返回一个<span><span class="heti-spacing"> </span>IO String</span></li>
<li><code>hGetChar</code> :: Handle -&gt; IO Char ，从<span class="heti-skip"><span class="heti-spacing"> </span>Handle<span class="heti-spacing"> </span></span>中读取一个字符</li>
<li><code>hGetLine</code> :: Handle -&gt; IO String ，从<span class="heti-skip"><span class="heti-spacing"> </span>Handle<span class="heti-spacing"> </span></span>中读取一行，返回一个<span><span class="heti-spacing"> </span>IO String</span></li>
<li><code>hPutStr</code> :: Handle -&gt; String -&gt; IO () ，向<span class="heti-skip"><span class="heti-spacing"> </span>Handle<span class="heti-spacing"> </span></span>中输出字符串</li>
<li><code>hPutStrLn</code> :: Handle -&gt; String -&gt; IO () ，同上</li>
</ul>
<p>在使用<span class="heti-skip"><span class="heti-spacing"> </span>openFile<span class="heti-spacing"> </span></span>进行文件操作后，需要使用<span class="heti-skip"><span class="heti-spacing"> </span>hClose<span class="heti-spacing"> </span></span>手动关闭<span><span class="heti-spacing"> </span>Handle</span>。hClose :: Handle -&gt; IO ()，接收一个<span class="heti-skip"><span class="heti-spacing"> </span>Handle<span class="heti-spacing"> </span></span>并返回<span><span class="heti-spacing"> </span>IO ()</span>，可以直接放在<span class="heti-skip"><span class="heti-spacing"> </span>main<span class="heti-spacing"> </span></span>函数末尾</p>
<p>所以使用<span class="heti-skip"><span class="heti-spacing"> </span>openFile<span class="heti-spacing"> </span></span>读取一个文件中的全部内容并输出的全部代码是：</p>
<pre><code class="language-haskell">import System.IO

main = do
    handle &lt;- openFile "text.txt" ReadMode
    contents &lt;- hGetContents handle
    putStrLn contents
    hClose handle
</code></pre>
<h4 id="withfile">withFile<a class="headerlink" href="#withfile" title="Permanent link">#</a></h4>
<p><span>withFile<span class="heti-spacing"> </span></span>类似<span class="heti-skip"><span class="heti-spacing"> </span>Python<span class="heti-spacing"> </span></span>中的<span><span class="heti-spacing"> </span>with open</span>，它在读取文件使用之后不需要手动<span class="heti-skip"><span class="heti-spacing"> </span>close<span class="heti-spacing"> </span></span>文件。它的类型是：</p>
<p style="text-align: center;">withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a</p>
<p>可以看出，它接收三个参数：</p>
<ul>
<li><code>FilePath</code>：一个表示文件路径的<span><span class="heti-spacing"> </span>String</span></li>
<li><code>IOMode</code>：打开文件的模式</li>
<li><code>(Handle -&gt; IO a)</code>：一个函数，表示对读取文件后的<span class="heti-skip"><span class="heti-spacing"> </span>Handle<span class="heti-spacing"> </span></span>索要进行的操作，需要返回一个<span><span class="heti-spacing"> </span>I/O action</span>；而这个返回值也将作为<span class="heti-skip"><span class="heti-spacing"> </span>withFile<span class="heti-spacing"> </span></span>的返回值</li>
</ul>
<p>现在使用<span class="heti-skip"><span class="heti-spacing"> </span>withFile<span class="heti-spacing"> </span></span>来改写上述代码：</p>
<pre><code class="language-haskell">import System.IO

main = withFile "text.txt" ReadMode (\handle -&gt; do
    contents &lt;- hGetContents handle
    putStrLn contents)
</code></pre>
<p><span>withFile<span class="heti-spacing"> </span></span>的功能相当于以下函数：</p>
<pre><code class="language-haskell">withFile' :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a  
withFile' path mode f = do  
    handle &lt;- openFile path mode   
    result &lt;- f handle  
    hClose handle  
    return result  
</code></pre>
<h4 id="readfile">readFile<a class="headerlink" href="#readfile" title="Permanent link">#</a></h4>
<p><span>readFile<span class="heti-spacing"> </span></span>可以更加简化读取文件内容的操作，它的类型：</p>
<p style="text-align: center;">readFile :: FilePath -&gt; IO String</p>
<p>它只需要输入一个表示文件路径的字符串，返回其中以其中内容为内容的<span><span class="heti-spacing"> </span>I/O action</span>：</p>
<pre><code class="language-haskell">import System.IO

main = do
    contents &lt;- readFile "text.txt"
    putStrLn contents
</code></pre>
<h4 id="writefile">writeFile<a class="headerlink" href="#writefile" title="Permanent link">#</a></h4>
<p><span>writeFile<span class="heti-spacing"> </span></span>简化了写入文件的操作，它的类型：</p>
<p style="text-align: center;">writeFile :: FilePath -&gt; String -&gt; IO ()</p>
<p>传入的第一个参数是要写入的文件的路径，第二个参数是要写入的字符串，返回一个<span><span class="heti-spacing"> </span>IO ()</span></p>
<h4 id="appendfile">appendFile<a class="headerlink" href="#appendfile" title="Permanent link">#</a></h4>
<p><span>appendFile<span class="heti-spacing"> </span></span>类似<span><span class="heti-spacing"> </span>writeFile</span>，但使用它不会覆盖文件中原来内容，而是直接把字符串添加到文件末尾</p>
<h4 id="buffer">buffer<a class="headerlink" href="#buffer" title="Permanent link">#</a></h4>
<p>文件以流的形式被读取，默认文字文件的缓冲区（buffer）大小是一行，即每次读取一行内容；默认二进制文件的缓冲区大小是以块为单位，如果没有指定则根据系统默认来选择。</p>
<p>也可以通过 <code>hSetBuffering</code> 函数来手动设置缓冲区大小，这个函数的类型：</p>
<p style="text-align: center;">hSetBuffering :: Handle -&gt; BufferMode -&gt; IO ()</p>
<p>它接收一个<span><span class="heti-spacing"> </span>handle</span>，和一个<span><span class="heti-spacing"> </span>BufferMode</span>，并返回<span><span class="heti-spacing"> </span>IO ()</span>。其中<span class="heti-skip"><span class="heti-spacing"> </span>BufferMode<span class="heti-spacing"> </span></span>有以下几种：</p>
<ul>
<li><code>NoBuffering</code>：没有缓冲区，一次读入一个字符</li>
<li><code>LineBuffering</code>：缓冲区大小是一行，即每次读入一行内容</li>
<li><code>BlockBuffering (Maybe Int)</code>：缓冲区大小是一块，块的大小由<span class="heti-skip"><span class="heti-spacing"> </span>Maybe Int<span class="heti-spacing"> </span></span>指定：<ul>
<li><code>BlockBuffering (Nothing)</code>：使用系统默认的块大小</li>
<li><code>BlockBuffering (Just 2048)</code>：一块的大小是<span class="heti-skip"><span class="heti-spacing"> </span>2048<span class="heti-spacing"> </span></span>字节，即每次读入<span class="heti-skip"><span class="heti-spacing"> </span>2048 bytes<span class="heti-spacing"> </span></span>的内容</li>
</ul>
</li>
</ul>
<p>缓冲区的刷新是自动的，也可以通过 <code>hFlush</code> 来手动刷新</p>
<p style="text-align: center;">hFlush :: Handle -&gt; IO ()</p>
<p>传入一个<span><span class="heti-spacing"> </span>handle</span>，返回<span><span class="heti-spacing"> </span>IO ()</span>，即刷新对应<span class="heti-skip"><span class="heti-spacing"> </span>handle<span class="heti-spacing"> </span></span>的缓冲区</p>
<h4 id="opentempfile">openTempFile<a class="headerlink" href="#opentempfile" title="Permanent link">#</a></h4>
<p><span>openTempFile<span class="heti-spacing"> </span></span>可以新建一个临时文件：</p>
<p style="text-align: center;">openTempFile :: FilePath -&gt; String -&gt; IO (FilePath, Handle)</p>
<p><code>FilePath</code> 指临时文件要创建的位置路径，<code>String</code> 指临时文件名字的前缀，返回一个<span><span class="heti-spacing"> </span>I/O action</span>，其内容第一个 <code>FilePath</code> 是创建得到的临时文件的路径，<code>Handle</code> 是临时文件的<span><span class="heti-spacing"> </span>handle</span></p>
<p>例如：</p>
<pre><code class="language-haskell">import System.IO

main = do
    (tempFile, tempHandle) &lt;- openTempFile "." "temp"
    ...
    hClose tempHandle
</code></pre>
<p><code>"."</code> 指临时文件要在当前目录创建，<code>"temp"</code> 指临时文件名字以<span class="heti-skip"><span class="heti-spacing"> </span>temp<span class="heti-spacing"> </span></span>开头。最终得到的<span class="heti-skip"><span class="heti-spacing"> </span>tempFile<span class="heti-spacing"> </span></span>就是<span><span class="heti-spacing"> </span>./temp.......</span>，<span>temp<span class="heti-spacing"> </span></span>后为随机数字，如<code>./temp43620-0</code></p>
<h3 id="_8">路径操作<a class="headerlink" href="#_8" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<p>相关函数都包含在 <code>System.Directory</code> 模块中，全部内容见<a href="https://hackage.haskell.org/package/directory-1.3.6.2/docs/System-Directory.html"><span><span class="heti-spacing"> </span>System.Directory</span></a></p>
<h4 id="getcurrentdirectory">getCurrentDirectory<a class="headerlink" href="#getcurrentdirectory" title="Permanent link">#</a></h4>
<p style="text-align: center;">getCurrentDirectory :: IO FilePath</p>
<p>直接返回一个<span><span class="heti-spacing"> </span>I/O action</span>，其内容是一个字符串表示当前路径的绝对路径</p>
<h4 id="removefile">removeFile<a class="headerlink" href="#removefile" title="Permanent link">#</a></h4>
<p style="text-align: center;">removeFile :: FilePath -&gt; IO ()</p>
<p>输入一个文件路径，并删除掉它</p>
<h4 id="renamefile">renameFile<a class="headerlink" href="#renamefile" title="Permanent link">#</a></h4>
<p style="text-align: center;">renameFile :: FilePath -&gt; FilePath -&gt; IO ()</p>
<p>输入一个原路径，一个新路径，为原路径的文件重命名为新路径的名</p>
<h4 id="doesfileexist">doesFileExist<a class="headerlink" href="#doesfileexist" title="Permanent link">#</a></h4>
<p style="text-align: center;">doesFileExist :: FilePath -&gt; IO Bool</p>
<p>检查文件是否存在，返回一个包含布尔值的<span><span class="heti-spacing"> </span>I/O action</span></p>
<h3 id="command_line_arguments">Command line arguments<a class="headerlink" href="#command_line_arguments" title="Permanent link">#</a></h3>
<p><code>System.Environment</code> 模块中提供了两个函数可以用来处理传入命令行的参数</p>
<h4 id="getargs">getArgs<a class="headerlink" href="#getargs" title="Permanent link">#</a></h4>
<p style="text-align: center;">getArgs :: IO [String]</p>
<p>不需要输入参数，直接返回一个<span><span class="heti-spacing"> </span>I/O action</span>，内容为传入命令行的参数（一个由<span class="heti-skip"><span class="heti-spacing"> </span>String<span class="heti-spacing"> </span></span>组成的列表<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。相当于<span class="heti-skip"><span class="heti-spacing"> </span>C<span class="heti-spacing"> </span></span>语言中的<span><span class="heti-spacing"> </span>argv[1:]</span></p>
<h4 id="getprogname">getProgName<a class="headerlink" href="#getprogname" title="Permanent link">#</a></h4>
<p style="text-align: center;">getProgName :: IO String</p>
<p>返回<span><span class="heti-spacing"> </span>I/O action</span>，内容为程序的名字，相当于<span class="heti-skip"><span class="heti-spacing"> </span>C<span class="heti-spacing"> </span></span>语言中的<span><span class="heti-spacing"> </span>argv[0]</span></p>
<h3 id="randomness">Randomness<a class="headerlink" href="#randomness" title="Permanent link">#</a></h3>
<p>和随机数有关的函数都包含在 <code>System.Random</code> 模块中。<span>GHCi<span class="heti-spacing"> </span></span>启动时可能不会包含<span class="heti-skip"><span class="heti-spacing"> </span>System.Random<span class="heti-spacing"> </span></span>的配置，导致无法找到模块。需要通过<span class="heti-skip"><span class="heti-spacing"> </span>stack<span class="heti-spacing"> </span></span>打开<span><span class="heti-spacing"> </span>:</span></p>
<pre><code class="language-sh">stack ghci --package random
</code></pre>
<p><span>Haskell<span class="heti-spacing"> </span></span>要求同样的程序需要运行出同样的结果，除了用到了<span><span class="heti-spacing"> </span>I/O action</span>，所有会造成不同结果的函数都要交给<span class="heti-skip"><span class="heti-spacing"> </span>I/O action<span class="heti-spacing"> </span></span>来完成</p>
<p>那要使随机数脱离<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>存在，就要用到随机生成器（random generator）</p>
<p><code>System.Random</code> 模块提供了几个生成随机数的函数：</p>
<h4 id="random">random<a class="headerlink" href="#random" title="Permanent link">#</a></h4>
<p style="text-align: center;">random :: (Random a, RandomGen g) =&gt; g -&gt; (a, g)</p>
<p>其中又有两个新的<span><span class="heti-spacing"> </span>typeclass</span>，<span>Random<span class="heti-spacing"> </span></span>表示可以取随机，<span>RandomGen<span class="heti-spacing"> </span></span>表示随机数生成器。<span>random<span class="heti-spacing"> </span></span>函数接收一个随机数生成器，返回一个元组，其中第一个元素是生成的随机数，第二个元素是一个新的随机数生成器</p>
<p>获取随机数生成器可以使用 <code>mkStdGen</code> 函数：</p>
<p style="text-align: center;">mkStdGen :: Int -&gt; StdGen</p>
<p>其中 <code>StdGen</code> 是一个<span class="heti-skip"><span class="heti-spacing"> </span>RandomGen<span class="heti-spacing"> </span></span>的实例</p>
<p>运用<span class="heti-skip"><span class="heti-spacing"> </span>random<span class="heti-spacing"> </span></span>生成随机数需要指定类型，不然程序无法确定 <code>a</code> 是什么类型。例如：</p>
<pre><code class="language-haskell">ghci&gt; random (mkStdGen 100) :: (Int, StdGen)
(9216477508314497915,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})
ghci&gt; random (mkStdGen 100) :: (Char, StdGen)
('\537310',StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})
ghci&gt; random (mkStdGen 100) :: (Bool, StdGen)
(True,StdGen {unStdGen = SMGen 712633246999323047 2532601429470541125})
</code></pre>
<p>再次运行同样的函数，会得到同样的结果。所以如果需要生成其他的随机数，需要更换生成器，就可以使用上一次调用结果返回的新随机数生成器：</p>
<pre><code class="language-haskell">threeCoins :: StdGen -&gt; (Bool, Bool, Bool)  
threeCoins gen =   
    let (firstCoin, newGen) = random gen  
        (secondCoin, newGen') = random newGen  
        (thirdCoin, newGen'') = random newGen'  
    in  (firstCoin, secondCoin, thirdCoin) 
</code></pre>
<h4 id="randoms">randoms<a class="headerlink" href="#randoms" title="Permanent link">#</a></h4>
<p style="text-align: center;">randoms :: (Random a, RandomGen g) =&gt; g -&gt; [a]</p>
<p><span>randoms<span class="heti-spacing"> </span></span>接收一个<span><span class="heti-spacing"> </span>RandomGen</span>，返回一个随机的无穷列表。因为它是无穷的，所以不会返回新的随机数生成器</p>
<h4 id="randomr">randomR<a class="headerlink" href="#randomr" title="Permanent link">#</a></h4>
<p style="text-align: center;">randomR :: (Random a, RandomGen g) =&gt; (a, a) -&gt; g -&gt; (a, g)</p>
<p>可以用来生成有范围的随机数，第一个参数是一个元组，表示生成随机数的范围<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>闭区间<span><span class="heti-spacing"> </span>)</span></p>
<h4 id="randomrs">randomRs<a class="headerlink" href="#randomrs" title="Permanent link">#</a></h4>
<p style="text-align: center;">randomRs :: (Random a, RandomGen g) =&gt; (a, a) -&gt; g -&gt; [a]</p>
<p>同上两个，生成有范围的无穷随机数列表</p>
<h4 id="getstdgen">getStdGen<a class="headerlink" href="#getstdgen" title="Permanent link">#</a></h4>
<p>如果想要让程序每次运行得到不同的随机结果，需要使用 <code>getStdGen</code> 来获取全局随机数生成器，它会在每次运行的时候产生不同的值，也因此，它返回的是一个<span><span class="heti-spacing"> </span>I/O action</span>，而不是一个直接的<span><span class="heti-spacing"> </span>StdGen</span></p>
<p style="text-align: center;">getStdGen :: Control.Monad.IO.Class.MonadIO m =&gt; m StdGen</p>
<p>即可以看成<span><span class="heti-spacing"> </span>getStdGen :: IO StdGen</span>，需要使用<span class="heti-skip"><span class="heti-spacing"> </span>&lt;-<span class="heti-spacing"> </span></span>操作符将<span class="heti-skip"><span class="heti-spacing"> </span>StdGen<span class="heti-spacing"> </span></span>提取出来</p>
<p>但是在同一个程序中，<span>getStdGen<span class="heti-spacing"> </span></span>的结果是相同的，全局随机数生成器不会自动更新，所以就需要另一个函数<span><span class="heti-spacing"> </span>newStdGen</span></p>
<h4 id="newstdgen">newStdGen<a class="headerlink" href="#newstdgen" title="Permanent link">#</a></h4>
<p style="text-align: center;">newStdGen :: Control.Monad.IO.Class.MonadIO m =&gt; m StdGen</p>
<p>执行<span class="heti-skip"><span class="heti-spacing"> </span>newStdGen<span class="heti-spacing"> </span></span>会进行两个操作：</p>
<ul>
<li>更新全局随机数生成器，下次执行<span class="heti-skip"><span class="heti-spacing"> </span>getStdGen<span class="heti-spacing"> </span></span>会获得不同的结果</li>
<li>返回一个<span><span class="heti-spacing"> </span>I/O action</span>，包含一个新的<span><span class="heti-spacing"> </span>StdGen</span>（但是这个生成器和全局生成器也不同）</li>
</ul>
<h3 id="exceptions">Exceptions<a class="headerlink" href="#exceptions" title="Permanent link">#</a></h3>
<p>程序在运行失败时会抛出异常，可以通过 <code>Control.Exception</code> 模块中的 <code>catch</code> 函数来捕获异常：</p>
<p style="text-align: center;">catch :: Exception e =&gt; IO a -&gt; (e -&gt; IO a) -&gt; IO a</p>
<p>第一个参数是要进行的操作，以<span class="heti-skip"><span class="heti-spacing"> </span>IO a<span class="heti-spacing"> </span></span>为返回值的类型，第二个参数是一个函数，它接收异常并进行操作，例如：</p>
<pre><code class="language-haskell">import Control.Exception

main = main' `catch` handler

main' :: IO ()
main' = do
    ...

handler :: Exception e =&gt; e -&gt; IO ()
handler e =  putStrLn "..."
</code></pre>
<p>也可以利用守卫（guard）语法和 <code>System.IO.Error</code> 中的函数来判断<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>异常的类型来进行不同操作：</p>
<pre><code class="language-haskell">import System.Environment
import System.IO.Error
import Control.Exception

main = toTry `catch` handler

toTry :: IO ()  
toTry = do (fileName:_) &lt;- getArgs  
           contents &lt;- readFile fileName  
           putStrLn $ "The file has " ++ show (length (lines contents)) ++ " lines!"  

handler :: IOError -&gt; IO ()  
handler e  
    | isDoesNotExistError e = putStrLn "The file doesn't exist!"  
    | otherwise = ioError e  
</code></pre>
<p>具体相关全部函数见文档：<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/System-IO-Error.html">System.IO.Error</a>、<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Control-Exception-Base.html">Control.Exception</a></p>
<hr/>
<h2 id="functors">Functors<a class="headerlink" href="#functors" title="Permanent link">#</a></h2>
<p>函子（Functor）是一个类型类（typeclass<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，和其他类型类一样，它规定了其实例类必须实现的功能（例如<span class="heti-skip"><span class="heti-spacing"> </span>Eq<span class="heti-spacing"> </span></span>类型类规定了它的实例必须是可以比较是否相等的<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，<span>Functor<span class="heti-spacing"> </span></span>规定类它的实例必须是可以进行映射的。<span>Functor<span class="heti-spacing"> </span></span>要求使用<code>fmap</code><span class="heti-skip"><span class="heti-spacing"> </span>:: (a -&gt; b) -&gt; f a -&gt; f b<span class="heti-spacing"> </span></span>函数来实现这个功能，它接收一个<span class="heti-skip"><span class="heti-spacing"> </span>a -&gt; b<span class="heti-spacing"> </span></span>类型的函数、一个内部元素为<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>类型的函子，返回一个内部元素为<span class="heti-skip"><span class="heti-spacing"> </span>b<span class="heti-spacing"> </span></span>类型的函子</p>
<p><span>Functor<span class="heti-spacing"> </span></span>可以比作盒子，那<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>函数就相当于给定一个函数和一个盒子，将盒子中的全部元素都应用这个函数，再返回应用函数后的盒子</p>
<p>函子的实例必须是一个<span class="heti-skip"><span class="heti-spacing"> </span>Kind<span class="heti-spacing"> </span></span>为<span class="heti-skip"><span class="heti-spacing"> </span>* -&gt; *<span class="heti-spacing"> </span></span>的类型构造器，因为它要求其是一个盒子，盒子在接收内容后才会成为一个具体的类型。<span>fmap<span class="heti-spacing"> </span></span>中的 <code>f a</code> 和 <code>f b</code> 也是因为 <code>f</code> 是一个类型构造器，在接收类型<span class="heti-skip"><span class="heti-spacing"> </span>a/b<span class="heti-spacing"> </span></span>后才会变成一个具体类型（<span>f a<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>f b</span>）出现在函数类型声明中</p>
<p><span>Functor<span class="heti-spacing"> </span></span>的定义是<span><span class="heti-spacing"> </span>:</span></p>
<pre><code class="language-haskell">class Functor f where
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
    (&lt;$) :: a -&gt; f a -&gt; f b
    (&lt;$) = fmap . const
</code></pre>
<p>可以发现<span class="heti-skip"><span class="heti-spacing"> </span>Functor<span class="heti-spacing"> </span></span>不仅需要<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>函数，还需要一个<span class="heti-skip"><span class="heti-spacing"> </span>&lt;$<span class="heti-spacing"> </span></span>函数，它接收一个<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>类型的变量和一个内容为<span class="heti-skip"><span class="heti-spacing"> </span>b<span class="heti-spacing"> </span></span>类型的函子，返回一个内容为<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>类型的函子；作用就是将传入的函子中的所有元素都替换为传入的第一个参数，比如：</p>
<pre><code class="language-Haskell">ghci&gt; 'a' &lt;$ [1, 2, 3]
"aaa"
</code></pre>
<p>但它不是声明一个函子实例必须的，因为它可以使用<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>const<span class="heti-spacing"> </span></span>函数复合来实现，其中<span class="heti-skip"><span class="heti-spacing"> </span>const<span class="heti-spacing"> </span></span>的类型签名：</p>
<p style="text-align: center;">const :: a -&gt; b -&gt; a</p>
<p>即接收两个参数，但始终只返回第一个参数</p>
<h3 id="functor"><span>Functor<span class="heti-spacing"> </span></span>实例<a class="headerlink" href="#functor" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<h4 id="_9">[]<a class="headerlink" href="#_9" title="Permanent link">#</a></h4>
<p>列表<span class="heti-skip"><span class="heti-spacing"> </span>[]<span class="heti-spacing"> </span></span>是一个函子，它通过<span class="heti-skip"><span class="heti-spacing"> </span>map<span class="heti-spacing"> </span></span>函数来实现<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>的功能：</p>
<pre><code class="language-haskell">instance Functor [] where
    fmap = map
</code></pre>
<p style="text-align: center;">map :: (a -&gt; b) -&gt; [a] -&gt; [b]</p>
<p><span>map<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>要求的相同，达成的目的也一致。<span>map<span class="heti-spacing"> </span></span>接收一个函数和一个列表，它会将列表中的所有元素都应用这个函数后再返回这个列表</p>
<h4 id="maybe">Maybe<a class="headerlink" href="#maybe" title="Permanent link">#</a></h4>
<p><span>Maybe<span class="heti-spacing"> </span></span>也具有<span><span class="heti-spacing"> </span>kind * -&gt; *</span>，它也是一个函子：</p>
<pre><code class="language-haskell">instance Functor Maybe where
    fmap f Nothing = Nothing
    fmap f (Just x) = Just (f x)

ghci&gt; fmap (*2) Nothing
Nothing
ghci&gt; fmap (*2) (Just 2)
Just 4
</code></pre>
<h4 id="either_a">Either a<a class="headerlink" href="#either_a" title="Permanent link">#</a></h4>
<p><span>Either<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>kind<span class="heti-spacing"> </span></span>是<span><span class="heti-spacing"> </span>* -&gt; * -&gt; *</span>，显然它不是函子，但是固定了一个传入类型的<span class="heti-skip"><span class="heti-spacing"> </span>Either a<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>kind<span class="heti-spacing"> </span></span>是<span><span class="heti-spacing"> </span>* -&gt; *</span>，也是一个函子：</p>
<pre><code class="language-haskell">instance Functor (Either a) where
    fmap f (Left x) = Left x
    fmap f (Right x) = Right (f x)

ghci&gt; fmap (*2) (Left 4)
Left 4
ghci&gt; fmap (*2) (Right 4)
Right 8
</code></pre>
<p>因为使用<span class="heti-skip"><span class="heti-spacing"> </span>Either<span class="heti-spacing"> </span></span>时一般用右值表示正常结果，左值表示异常信息，所以使用<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>时只对右值进行操作，如果时左值则保持不变（而且左值此时也作为确定类型确定值存在）</p>
<h4 id="io_1">IO<a class="headerlink" href="#io_1" title="Permanent link">#</a></h4>
<p><span>IO<span class="heti-spacing"> </span></span>也是一个函子，使用<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>对<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>中内容应用函数：</p>
<pre><code class="language-haskell">instance Functor IO where
    fmap f action = do
        result &lt;- action
        return (f result)

ghci&gt; fmap ("input: "++) getLine
test
"input: test"
</code></pre>
<h4 id="a">(,) a<a class="headerlink" href="#a" title="Permanent link">#</a></h4>
<p><span>(,)<span class="heti-spacing"> </span></span>表示一个二元组的类型构造器，(,) :: * -&gt; * -&gt; *，而确定了第一个元素的类型后就变成了<span><span class="heti-spacing"> </span>(,) a</span>，它的<span class="heti-skip"><span class="heti-spacing"> </span>kind<span class="heti-spacing"> </span></span>是<span><span class="heti-spacing"> </span>* -&gt; *</span>。也是一个函子，进行<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>函数时只对第二个元素应用：</p>
<pre><code class="language-haskell">instance Functor ((,) a) where
    fmap f (x, y) = (x, f y)
</code></pre>
<p>只剩一个元素的三元组和四元组也都是函子，<span>fmap<span class="heti-spacing"> </span></span>也只对最后一个元素应用：</p>
<pre><code class="language-haskell">instance Functor ((,,) a b) where
    fmap f (a, b, c) = (a, b, f c)

instance Functor ((,,,) a b c) where
    fmap f (a, b, c, d) = (a, b, c, f d)
</code></pre>
<h4 id="-_r">(-&gt;) r<a class="headerlink" href="#-_r" title="Permanent link">#</a></h4>
<p><span>-&gt;<span class="heti-spacing"> </span></span>也是一个类型构造器，它的<span><span class="heti-spacing"> </span>kind</span>：</p>
<p style="text-align: center;">(-&gt;) :: * -&gt; * -&gt; *</p>
<p>一个映射（一元函数）的类型<span class="heti-skip"><span class="heti-spacing"> </span>a -&gt; b<span class="heti-spacing"> </span></span>也可以写成<span><span class="heti-spacing"> </span>(-&gt;) a b</span>，它是由类型<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>和类型<span class="heti-skip"><span class="heti-spacing"> </span>b<span class="heti-spacing"> </span></span>输入到类型构造器<span class="heti-skip"><span class="heti-spacing"> </span>-&gt;<span class="heti-spacing"> </span></span>中后形成的一个具体类型。所以确定了输入类型后的一元函数的类型就是<span><span class="heti-spacing"> </span>(-&gt;) r</span>（其中 <code>r</code> 是输入的类型）</p>
<p>规定的<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>的类型签名是：</p>
<p style="text-align: center;">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</p>
<p>其中的<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>是函子，而在这个实例中<span class="heti-skip"><span class="heti-spacing"> </span>(-&gt;) r<span class="heti-spacing"> </span></span>就是函子，将其带入<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>可以得到：</p>
<p style="text-align: center;">fmap :: (a -&gt; b) -&gt; ((-&gt; r) a) -&gt; ((-&gt; r) b)</p>
<p>把其中的<span class="heti-skip"><span class="heti-spacing"> </span>(-&gt;)<span class="heti-spacing"> </span></span>换成中缀可以得到：</p>
<p style="text-align: center;">fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</p>
<p>传入两个函数，一个类型为<span><span class="heti-spacing"> </span>a -&gt; b</span>，一个类型为<span><span class="heti-spacing"> </span>r -&gt; a</span>，返回一个函数，类型为<span><span class="heti-spacing"> </span>r -&gt; b</span>。<br/>
不难推测这个 fmap 是将这两个函数复合了，先对输入对 r 应用第二个函数产生类型 a 的结果，然后在应用第一个函数产生类型 b 的结果，所以 (-&gt;) r 定义的 fmap 是：</p>
<pre><code class="language-haskell">instance Functor ((-&gt;) r) where
    fmap f g = (\x -&gt; f (g x))
</code></pre>
<p>所以<span class="heti-skip"><span class="heti-spacing"> </span>(-&gt;) r<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>其实就是函数复合<span><span class="heti-spacing"> </span>(.)</span>：</p>
<pre><code class="language-haskell">instance Functor ((-&gt;) r) where
    fmap = (.)
</code></pre>
<pre><code class="language-haskell">ghci&gt; :t fmap (*3) (+100)  
fmap (*3) (+100) :: (Num a) =&gt; a -&gt; a  
ghci&gt; fmap (*3) (+100) 1  
303  
ghci&gt; (*3) `fmap` (+100) $ 1  
303  
ghci&gt; (*3) . (+100) $ 1  
303
</code></pre>
<h3 id="functor_laws">Functor Laws<a class="headerlink" href="#functor_laws" title="Permanent link">#</a></h3>
<p>所有的函子都应该满足两个定律。这两个定律不是<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>强制要求的，但应该确保一个函子满足这两个定律：</p>
<ol>
<li><code>fmap id = id</code>（其中<span class="heti-skip"><span class="heti-spacing"> </span>id<span class="heti-spacing"> </span></span>为函数 <code>(\x -&gt; x)</code><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：即对一个函子<span><span class="heti-spacing"> </span>fmap id</span>，那它应该返回本身（fmap id a = id a = a，<span>a<span class="heti-spacing"> </span></span>为一个函子<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，比如：
    <code>haskell
    ghci&gt; fmap id [1, 2, 3]
    [1,2,3]
    ghci&gt; fmap id (Just 2)
    Just 2</code></li>
<li><code>fmap (f . g) = fmap f . fmap g</code>：即函子的<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>支持结合律
    fmap (f . g) a = fmap f . fmap g $ a = fmap f (fmap g a)，其中<code>a</code>为一个函子
    fmap (f . g) (Just x) = fmap f (fmap g (Just x)) = fmap f (Just (g x)) = Just (f (g x))
    <code>haskell
    ghci&gt; fmap ((*3) . (+100)) (Just 1)
    Just 303</code></li>
</ol>
<p>满足第一个定律的函子一定满足第二个定律，所以只要检查函子是否满足第一个定律即可</p>
<h3 id="intuition">Intuition<a class="headerlink" href="#intuition" title="Permanent link">#</a></h3>
<p>对于函子和<span><span class="heti-spacing"> </span>fmap</span>，有两种理解方法</p>
<ol>
<li>函子是一种容器（container<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>；<span>fmap<span class="heti-spacing"> </span></span>接收一个函数和一个容器，在容器内部应用这个函数，返回应用后的新容器</li>
<li>函子是一种计算上下文（context<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>；<span>fmap<span class="heti-spacing"> </span></span>是柯里化的，把其类型签名看作</li>
</ol>
<p style="text-align: center;">fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</p>
<p>  接收一个函数返回另一个函数，传入函数<span><span class="heti-spacing"> </span>g :: a -&gt; b</span>，<span>fmap<span class="heti-spacing"> </span></span>将其转换为新的函数</p>
<p style="text-align: center;">fmap g :: f a -&gt; f b</p>
<p>  使普通的函数<span class="heti-skip"><span class="heti-spacing"> </span>g<span class="heti-spacing"> </span></span>可以在计算上下文<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>中使用，这种转换也被称为提升（lift）</p>
<h3 id="_10">常用函数<a class="headerlink" href="#_10" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<h4 id="_11">&lt;$&gt;<a class="headerlink" href="#_11" title="Permanent link">#</a></h4>
<p><code>&lt;$&gt;</code> 函数是 <code>fmap</code> 的中缀形式（它看着类似 <code>$</code>，<code>f $ 3</code> 将<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>应用在单个值<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>上，而 <code>f &lt;$&gt; [1, 2, 3]</code> 将<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>应用在一个函子上，也就是应用在一个函子内部的所有值上<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<pre><code class="language-haskell">ghci&gt; fmap (*2) (Just 2)
4
ghci&gt; (*2) &lt;$&gt; Just 2
4
</code></pre>
<h4 id="_12">$&gt;<a class="headerlink" href="#_12" title="Permanent link">#</a></h4>
<p><code>$&gt;</code> 函数包含在 <code>Data.Functor</code> 模块中</p>
<p style="text-align: center;">($&gt;) :: Functor f =&gt; f a -&gt; b -&gt; f b</p>
<p><span>Functor<span class="heti-spacing"> </span></span>定义时要求了 <code>&lt;$</code> 函数，将函子内部的元素全部替换为指定的某个值，而 <code>$&gt;</code> 正好将 <code>&lt;$</code> 函数的两个参数反了过来，相当于 <code>flip (&lt;$)</code>：</p>
<pre><code class="language-haskell">ghci&gt; 'a' &lt;$ [1, 2, 3]
"aaa"
ghci&gt; [1, 2, 3] $&gt; 'a'
"aaa"
</code></pre>
<h4 id="void">void<a class="headerlink" href="#void" title="Permanent link">#</a></h4>
<p><code>void</code> 函数也包含在 <code>Data.Functor</code> 模块中</p>
<p style="text-align: center;">void :: Functor f =&gt; f a -&gt; f ()</p>
<p><span>void<span class="heti-spacing"> </span></span>函数把一个函子内部的全部元素都变成空（<code>()</code><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，<code>void x</code> 相当于 <code>() &lt;$ x</code>：</p>
<pre><code class="language-haskell">ghci&gt; void [1, 2, 3]
[(), (), ()]
ghci&gt; void (Just 2)
Just ()
</code></pre>
<hr/>
<h2 id="applicative_functor">Applicative Functor<a class="headerlink" href="#applicative_functor" title="Permanent link">#</a></h2>
<p>应用函子（Applicative Functor）是函子的升级版，它包含在 <code>Control.Applicative</code> 模块中。</p>
<p><span>fmap<span class="heti-spacing"> </span></span>进行的操作是将一个普通一元函数应用在一个函子内部。而如果要将一个包含函数的函子应用在另一个函子上，<span>fmap<span class="heti-spacing"> </span></span>就处理不了了，但是应用函子的方法可以处理。应用函子的定义：</p>
<pre><code class="language-haskell">class Functor f =&gt; Applicative f where
    pure :: a -&gt; f a
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>应用函子要求实现两个函数：</p>
<ul>
<li><code>pure</code> :: a -&gt; f a，不难理解，<span>pure<span class="heti-spacing"> </span></span>接收一个值，并将其放在默认的上下文<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>容器中。对于列表，pure = []；对于<span><span class="heti-spacing"> </span>Maybe</span>，pure = Just</li>
<li><code>&lt;*&gt;</code> :: f (a -&gt; b) -&gt; f a -&gt; f b，类似于<span><span class="heti-spacing"> </span>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span>，但不同的是<span class="heti-skip"><span class="heti-spacing"> </span>&lt;*&gt;<span class="heti-spacing"> </span></span>的第一个参数的类型是<span class="heti-skip"><span class="heti-spacing"> </span>f (a -&gt; b)<span class="heti-spacing"> </span></span>不是<span><span class="heti-spacing"> </span>a -&gt; b</span>。所以<span class="heti-skip"><span class="heti-spacing"> </span>&lt;*&gt;<span class="heti-spacing"> </span></span>的第一个参数是在上下文中的函数，而不是一个普通函数。换句话说，<span>&lt;*&gt;<span class="heti-spacing"> </span></span>接收一个装有函数的函子和另一个函子，应用函数后返回新的函子。</li>
</ul>
<h3 id="applicative_functor_1"><span>Applicative Functor<span class="heti-spacing"> </span></span>实例<a class="headerlink" href="#applicative_functor_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<h4 id="maybe_1">Maybe<a class="headerlink" href="#maybe_1" title="Permanent link">#</a></h4>
<p><span>Maybe<span class="heti-spacing"> </span></span>是一个应用函子：</p>
<pre><code class="language-haskell">instance Applicative Maybe where
    pure = Just
    Nothing &lt;*&gt; _ = Nothing
    (Just f) &lt;*&gt; something = fmap f something
</code></pre>
<ul>
<li><code>pure</code> 函数：将一个值放在默认的上下文中，而对于<span><span class="heti-spacing"> </span>Maybe</span>，默认的上下文就是<span><span class="heti-spacing"> </span>Just</span>，所以<span><span class="heti-spacing"> </span>pure x = Just x</span></li>
<li><code>&lt;*&gt;</code> 函数：将装有函数的函子中的函数应用另一个函子中<ul>
<li>第一个参数是<span><span class="heti-spacing"> </span>Nothing</span>，即第一个函子不包含函数，那返回的结果就也会是<span><span class="heti-spacing"> </span>Nothing</span></li>
<li>第一个参数是装有函数<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>的函子<span><span class="heti-spacing"> </span>Just f</span>，将其中的函数<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>应用在函子<span class="heti-skip"><span class="heti-spacing"> </span>something<span class="heti-spacing"> </span></span>中，只需要将<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>提取出来使用<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>应用在函子<span class="heti-skip"><span class="heti-spacing"> </span>something<span class="heti-spacing"> </span></span>中即可</li>
</ul>
</li>
</ul>
<p>实际应用的例子：</p>
<pre><code class="language-haskell">ghci&gt; Just (+3) &lt;*&gt; Just 9
Just 12
ghci&gt; pure (+3) &lt;*&gt; Just 9
Just 12
ghci&gt; (+3) &lt;$&gt; Just 9
Just 12
ghci&gt; Nothing &lt;*&gt; Just 9
Nothing
</code></pre>
<p>第一个例子，<span>Just (+3)<span class="heti-spacing"> </span></span>是一个包含函数<span class="heti-skip"><span class="heti-spacing"> </span>(+3)<span class="heti-spacing"> </span></span>的函子，将其应用在函子<span class="heti-skip"><span class="heti-spacing"> </span>Just 9<span class="heti-spacing"> </span></span>中，将<span class="heti-skip"><span class="heti-spacing"> </span>Just (+3)<span class="heti-spacing"> </span></span>中的函数<span class="heti-skip"><span class="heti-spacing"> </span>(+3)<span class="heti-spacing"> </span></span>提取出来，应用在<span class="heti-skip"><span class="heti-spacing"> </span>Just 9<span class="heti-spacing"> </span></span>中，得到了<span><span class="heti-spacing"> </span>Just 12</span></p>
<p>第二个例子，可以发现，在这里<span class="heti-skip"><span class="heti-spacing"> </span>pure (+3)<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>Just (+3)<span class="heti-spacing"> </span></span>等效，因为<span class="heti-skip"><span class="heti-spacing"> </span>pure<span class="heti-spacing"> </span></span>将函数<span class="heti-skip"><span class="heti-spacing"> </span>(+3)<span class="heti-spacing"> </span></span>放在默认上下文中，也就是<span class="heti-skip"><span class="heti-spacing"> </span>Just<span class="heti-spacing"> </span></span>中了</p>
<p>而<span class="heti-skip"><span class="heti-spacing"> </span>&lt;*&gt;<span class="heti-spacing"> </span></span>能做的不止这些，他可以连续传入更多函子作为参数，比如：</p>
<pre><code class="language-haskell">ghci&gt; pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 9
Just 12
ghci&gt; pure (\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5
Just 12
</code></pre>
<p><span>&lt;*&gt;<span class="heti-spacing"> </span></span>函数一样是默认左结合的，pure (+) &lt;<em>&gt; Just 3 &lt;</em><span>&gt; Just 9<span class="heti-spacing"> </span></span>相当于<span><span class="heti-spacing"> </span>(pure (+) &lt;</span><em>&gt; Just 3) &lt;</em>&gt; Just 9，而<span><span class="heti-spacing"> </span>pure (+) &lt;</span><em><span>&gt; Just 3<span class="heti-spacing"> </span></span>将<span class="heti-skip"><span class="heti-spacing"> </span>(+)<span class="heti-spacing"> </span></span>应用在<span class="heti-skip"><span class="heti-spacing"> </span>Just 3<span class="heti-spacing"> </span></span>上，得到的就是<span class="heti-skip"><span class="heti-spacing"> </span>Just (+3)<span class="heti-spacing"> </span></span>一个包含函数的函子，又将其通过<span><span class="heti-spacing"> </span>&lt;</span></em><span>&gt;<span class="heti-spacing"> </span></span>应用在了<span class="heti-skip"><span class="heti-spacing"> </span>Just 9<span class="heti-spacing"> </span></span>上，得到了<span><span class="heti-spacing"> </span>Just 12:</span></p>
<pre><code class="language-haskell">  pure (\x y z -&gt; x + y + z) &lt;*&gt; Just 3 &lt;*&gt; Just 4 &lt;*&gt; Just 5
= (pure (\x y z -&gt; x + y + z) &lt;*&gt; Just 3) &lt;*&gt; Just 4 &lt;*&gt; Just 5
= (Just (\y z -&gt; 3 + y + z) &lt;*&gt; Just 4) &lt;*&gt; Just 5
= Just (\z -&gt; 3 + 4 + z) &lt;*&gt; Just 5 = Just (+7) &lt;*&gt; Just 5
= Just 12
</code></pre>
<p>所以可以使用类似<span><span class="heti-spacing"> </span>pure f &lt;</span><em>&gt; x &lt;</em><span>&gt; y &lt;*&gt; ...<span class="heti-spacing"> </span></span>来将一个普通多元函数<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>应用在多个函子上。</p>
<p>而且<span><span class="heti-spacing"> </span>pure f &lt;</span><em><span>&gt; x<span class="heti-spacing"> </span></span>实际上先将普通函数<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>放在上下文中，然后执行<span><span class="heti-spacing"> </span>&lt;</span></em><span>&gt;<span class="heti-spacing"> </span></span>时再将其提取出来执行<span><span class="heti-spacing"> </span>fmap</span>，所以它就相当于将普通函数应用在函子<span class="heti-skip"><span class="heti-spacing"> </span>x<span class="heti-spacing"> </span></span>上，即<span><span class="heti-spacing"> </span>fmap f x</span>，也可以写成<span><span class="heti-spacing"> </span>f &lt;$&gt; x</span>。所以常用的写法就是：</p>
<p style="text-align: center;">f  x  y  ...</p>
<h4 id="_13">[]<a class="headerlink" href="#_13" title="Permanent link">#</a></h4>
<p>列表也是一个应用函子：</p>
<pre><code class="language-haskell">instance Applicative [] where
    pure x = [x]
    fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]
</code></pre>
<ul>
<li><code>pure</code> 函数：对于列表而言，一个值的最小上下文就是只包含这个值的列表<span><span class="heti-spacing"> </span>[x]</span></li>
<li><code>&lt;*&gt;</code> 函数：列表的<span class="heti-skip"><span class="heti-spacing"> </span>&lt;*&gt;<span class="heti-spacing"> </span></span>函数是通过列表推导来实现的。因为不同于<span class="heti-skip"><span class="heti-spacing"> </span>Maybe<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>Just<span class="heti-spacing"> </span></span>只包含一个值，列表可以包含很多值，第一个传入的列表中可能会包含很多函数，第二个传入的列表也会包含很多值，所以就需要先从第一个列表中取出一个函数然后依次应用在第二个列表的每个值中，再取出第一个列表中的第二个函数应用在第二个列表的每个值中……最终返回得到的所有结果的列表</li>
</ul>
<p>使用例子：</p>
<pre><code class="language-haskell">ghci&gt; [(+3), (*2)] &lt;*&gt; [1, 2]
[4,5,2,4]
ghci&gt; [(+), (*)]  &lt;*&gt;  [1, 2]  &lt;*&gt;  [3, 4]  
[4, 5, 5, 6, 3, 4, 6, 8]
</code></pre>
<h4 id="io_2">IO<a class="headerlink" href="#io_2" title="Permanent link">#</a></h4>
<pre><code class="language-haskell">instance Applicative IO where
    pure = return
    a &lt;*&gt; b = do
        f &lt;- a
        x &lt;- b
        return (f x)
</code></pre>
<p>也不难理解，<span>pure<span class="heti-spacing"> </span></span>函数直接将传入的值<span><span class="heti-spacing"> </span>return</span>，相当于放在了<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>的上下文中。而<span class="heti-skip"><span class="heti-spacing"> </span>&lt;*&gt;<span class="heti-spacing"> </span></span>函数先将两个<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>中内容提取出来，然后应用函数后<span><span class="heti-spacing"> </span>return</span>，形成新的<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>函子</p>
<pre><code class="language-haskell">ghci&gt; (++) &lt;$&gt; getLine &lt;*&gt; getLine
Line1
Line2
"Line1Line2"
</code></pre>
<h4 id="-_r_1">(-&gt;) r<a class="headerlink" href="#-_r_1" title="Permanent link">#</a></h4>
<p><span>(-&gt;) r<span class="heti-spacing"> </span></span>同样也是一个应用函子，和函子的分析一样，先来分析它的<span class="heti-skip"><span class="heti-spacing"> </span>&lt;*&gt;<span class="heti-spacing"> </span></span>函数的类型签名：</p>
<p style="text-align: center;"> :: f (a -&gt; b) -&gt; f a -&gt; f b</p>
<p>其中<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>为<span><span class="heti-spacing"> </span>(-&gt;) r</span>，将其代入并替换为中缀：</p>
<p style="text-align: center;"> :: (r -&gt; a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</p>
<p>可以看出它接收两个函数<span><span class="heti-spacing"> </span>f :: r -&gt; a -&gt; b</span>、g :: r -&gt; a，返回另一个函数<span><span class="heti-spacing"> </span>h :: (r -&gt; b)</span></p>
<p>那么返回的函数的输入为<span><span class="heti-spacing"> </span>r</span>，输出为<span><span class="heti-spacing"> </span>b</span>，所以先对输入应用函数<span class="heti-skip"><span class="heti-spacing"> </span>g<span class="heti-spacing"> </span></span>得到<span><span class="heti-spacing"> </span>a</span>，然后在对<span class="heti-skip"><span class="heti-spacing"> </span>r<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>应用<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>得到<span><span class="heti-spacing"> </span>b</span>，所以推测<span class="heti-skip"><span class="heti-spacing"> </span>&lt;*&gt;<span class="heti-spacing"> </span></span>函数的操作就是：</p>
<p style="text-align: center;">\x -&gt; f x (g x)</p>
<p>于是：</p>
<pre><code class="language-haskell">instance Applicative ((-&gt;) r) where
    pure x = (\_ -&gt; x)
    f &lt;*&gt; g = \x -&gt; f x (g x)
</code></pre>
<p>将一个值放在函数的上下文中，最小上下文就应该返回这个值本身，所以<span class="heti-skip"><span class="heti-spacing"> </span>pure<span class="heti-spacing"> </span></span>函数定义为<span><span class="heti-spacing"> </span>(_ -&gt; x)</span>，即无论输入什么，都返回<span><span class="heti-spacing"> </span>x</span></p>
<p>应用函子的<span class="heti-skip"><span class="heti-spacing"> </span>&lt;*&gt;<span class="heti-spacing"> </span></span>函数接收两个函子，返回一个新的函子。对于<span><span class="heti-spacing"> </span>(-&gt;) r</span>，它接收两个函数，返回一个新的函数。具体例子：</p>
<pre><code class="language-haskell">ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5
508
</code></pre>
<p>执行这句时发生了什么？：</p>
<pre><code class="language-haskell">  (+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5
= ((+) &lt;$&gt; (+3)) &lt;*&gt; (*100) $ 5
= ((+) . (+3)) &lt;*&gt; (*100) $ 5 = (\a -&gt; (+) ((+3) a)) &lt;*&gt; (*100) $ 5
= (\a b -&gt; (a + 3 + b)) &lt;*&gt; (*100) $ 5
= (\x -&gt; x + 3 + ((*100) x)) $ 5
= (\x -&gt; x + 3 + x * 100) $ 5
= 5 + 3 + 5 * 100 = 508
= (5 + 3) + (5 * 100)
</code></pre>
<p>所以就相当于先对输入分别执行<span class="heti-skip"><span class="heti-spacing"> </span>(+3)<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>(*100)</span>，然后将两个结果执行了<span><span class="heti-spacing"> </span>(+)</span></p>
<p>同样：</p>
<pre><code class="language-haskell">ghci&gt; (\x y z -&gt; [x,y,z]) &lt;$&gt; (+3) &lt;*&gt; (*2) &lt;*&gt; (/2) $ 5  
[8.0,10.0,2.5]  
</code></pre>
<p>先对<span class="heti-skip"><span class="heti-spacing"> </span>5<span class="heti-spacing"> </span></span>分别执行<span><span class="heti-spacing"> </span>(+3)</span>、(*2)、(/2)，然后将得到的三个结果传入<span class="heti-skip"><span class="heti-spacing"> </span>(\x y z -&gt; [x,y,z])<span class="heti-spacing"> </span></span>得到了最终的结果</p>
<pre><code class="language-haskell">  f &lt;$&gt; g &lt;*&gt; h &lt;*&gt; i
= (\x -&gt; f (g x) (h x) (i x))
</code></pre>
<h4 id="ziplist">ZipList<a class="headerlink" href="#ziplist" title="Permanent link">#</a></h4>
<p>普通列表实现的<span class="heti-skip"><span class="heti-spacing"> </span>&lt;*&gt;<span class="heti-spacing"> </span></span>函数是将每个函数应用在所有值上，但还有一种实现方法是将每个函数应用在对应值上，因为同一个类型不能存在同一函数的两种实现形式，所以引入了一个新的列表<span><span class="heti-spacing"> </span>ZipList</span>，包含在 <code>Control.Applicative</code> 模块中</p>
<pre><code class="language-haskell">instance Applicative ZipList where
    pure x = ZipList (repeat x)
    ZipList fs &lt;*&gt; ZipList xs = ZipList (zipWith ($) fs xs)
</code></pre>
<p>但是<span class="heti-skip"><span class="heti-spacing"> </span>ZipList<span class="heti-spacing"> </span></span>并不是<span class="heti-skip"><span class="heti-spacing"> </span>Show<span class="heti-spacing"> </span></span>的实例，所以不能直接显示出来，要使用 <code>getZipList</code> 来获取它内部的列表：</p>
<pre><code class="language-haskell">ghci&gt; getZipList $ (+) &lt;$&gt; ZipList [1,2,3] &lt;*&gt; ZipList [100,100..]  
[101,102,103]
ghci&gt; getZipList $ (,,) &lt;$&gt; ZipList "dog" &lt;*&gt; ZipList "cat" &lt;*&gt; ZipList "rat"  
[('d','c','r'),('o','a','a'),('g','t','t')]  
</code></pre>
<h3 id="applicative_functor_laws">Applicative Functor Laws<a class="headerlink" href="#applicative_functor_laws" title="Permanent link">#</a></h3>
<p>应用函子一般有四个定律，都是保证<span class="heti-skip"><span class="heti-spacing"> </span>pure<span class="heti-spacing"> </span></span>的正确性的：</p>
<ol>
<li><code>Identity law</code>：pure id &lt;*&gt; v = v</li>
<li><code>Homomorphism</code>：pure f &lt;*&gt; pure x = pure (f x)</li>
<li><code>Interchange</code>：u &lt;<em>&gt; pure v = pure ($ v) &lt;</em>&gt; u</li>
<li><code>Composition</code>：u &lt;<em>&gt; (v &lt;</em>&gt; w) = pure (.) &lt;<em>&gt; u &lt;</em>&gt; v &lt;*&gt; w</li>
</ol>
<h3 id="intuition_1">Intuition<a class="headerlink" href="#intuition_1" title="Permanent link">#</a></h3>
<p>理解应用函子的方式也是将其看作是计算上下文（context<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，比如要计算：</p>
<p>$$
[[\ \ g\ x_1\ x_2\ \cdots\ x_n\ \ ]]
$$</p>
<p>其中<span class="heti-skip"><span class="heti-spacing"> </span>$x_i$<span class="heti-spacing"> </span></span>的类型是<span><span class="heti-spacing"> </span>$f\ t_i$</span>，<span>$f$<span class="heti-spacing"> </span></span>是应用函子（看作上下文<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。而函数<span class="heti-skip"><span class="heti-spacing"> </span>$g$<span class="heti-spacing"> </span></span>的类型是：</p>
<p>$$
t_1\to t_2\to\cdots\to t_n\to t
$$</p>
<p>所以双括号（idiom brackets）的作用是将一个普通函数应用在包含在上下文中的参数上。<span>$g\ x_1$<span class="heti-spacing"> </span></span>可以通过<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>来执行，将<span class="heti-skip"><span class="heti-spacing"> </span>$g$<span class="heti-spacing"> </span></span>提升（lift）到<span class="heti-skip"><span class="heti-spacing"> </span>$x_1$<span class="heti-spacing"> </span></span>的上下文中，然后应用在<span class="heti-skip"><span class="heti-spacing"> </span>$x_1$<span class="heti-spacing"> </span></span>上。但是<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>返回的结果是一个函子，换句话说，<span>$g\ x_1$<span class="heti-spacing"> </span></span>结果的类型是：</p>
<p>$$
f\ \ (t_2\to t_3\to\cdots\to t_n\to t)
$$</p>
<p>但是<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>并不能将上下文中的函数应用在上下文中的参数上，于是应用函子的<span class="heti-skip"><span class="heti-spacing"> </span>&lt;*&gt;<span class="heti-spacing"> </span></span>函数提供了这个方法，所以计算<span><span class="heti-spacing"> </span>$[[\ g\ x_1\ x_2\ \cdots\ x_n\ ]]$</span>，只需要：</p>
<p style="text-align: center;">g  x1  x2  ...  xn</p>
<p>而<span class="heti-skip"><span class="heti-spacing"> </span>pure<span class="heti-spacing"> </span></span>函数的作用就是将一个不在上下文中的值（函数或参数）提升到上下文中，但不进行其他操作。比如参数<span class="heti-skip"><span class="heti-spacing"> </span>$x_2$<span class="heti-spacing"> </span></span>如果不在上下文中，需要用<span class="heti-skip"><span class="heti-spacing"> </span>pure<span class="heti-spacing"> </span></span>提升到上下文中才能按上面计算：</p>
<p style="text-align: center;">g  x1  pure x2  ...  xn</p>
<h3 id="_14">常用函数<a class="headerlink" href="#_14" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<h4 id="lifta_lifta2_lifta3">liftA &amp; liftA2 &amp; liftA3<a class="headerlink" href="#lifta_lifta2_lifta3" title="Permanent link">#</a></h4>
<p style="text-align: center;">liftA :: Applicative f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</p>
<p style="text-align: center;">liftA2 :: Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</p>
<p style="text-align: center;">liftA3 :: Applicative f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d</p>
<p>不难推测<span class="heti-skip"><span class="heti-spacing"> </span>liftA<span class="heti-spacing"> </span></span>就是<span><span class="heti-spacing"> </span>fmap</span>，<code>liftA2 f x1 x2</code> 相当于 <code>f &lt;$&gt; x1 &lt;*&gt; x2</code>，<code>liftA3 f x1 x2 x3</code> 相当于 <code>f &lt;$&gt; x1 &lt;*&gt; x2 &lt;*&gt; x3</code></p>
<h4 id="_15">&lt;* &amp; *&gt;<a class="headerlink" href="#_15" title="Permanent link">#</a></h4>
<p>类型类似函子的 <code>&lt;$</code> 和 <code>$&gt;</code>：</p>
<p style="text-align: center;">(&lt;*) :: Applicative f =&gt; f a -&gt; f b -&gt; f a</p>
<p style="text-align: center;">(*&gt;) :: Applicative f =&gt; f a -&gt; f b -&gt; f b</p>
<p><span>&lt;*<span class="heti-spacing"> </span></span>接收两个函子，如果两个函子中又一个为空，就返回空，否则返回的类型与第一个函子相同。<span>*&gt;<span class="heti-spacing"> </span></span>反过来</p>
<pre><code class="language-haskell">ghci&gt; Just 3 &lt;* Just 4
Just 3
ghci&gt; Just 3 *&gt; Just 4
Just 4
ghci&gt; Nothing &lt;* Just 3
Nothing
ghci&gt; Nothing *&gt; Just 3
Nothing
ghci&gt; [1, 2, 3] &lt;* [3, 4]
[1,1,2,2,3,3]
ghci&gt; [1, 2, 3] *&gt; [3, 4]
[3,4,3,4,3,4]
ghci&gt; [] &lt;* [1, 2, 3]
[]
ghci&gt; [] *&gt; [1, 2, 3]
[]
</code></pre>
<h4 id="_16">&lt;**&gt;<a class="headerlink" href="#_16" title="Permanent link">#</a></h4>
<p style="text-align: center;">() :: Applicative f =&gt; f a -&gt; f (a -&gt; b) -&gt; f b</p>
<p>接收的参数是<span class="heti-skip"><span class="heti-spacing"> </span>&lt;*&gt;<span class="heti-spacing"> </span></span>反转过来的，即先接收一个参数函子，然后接收一个函数函子，在将其应用返回。但是和<span class="heti-skip"><span class="heti-spacing"> </span>flip(&lt;*&gt;)<span class="heti-spacing"> </span></span>不同，它先取参数函子的每个参数，然后再取函数函子中的函数逐个应用：</p>
<pre><code class="language-haskell">ghci&gt; [(+1), (+2), (+3)] &lt;*&gt; [1, 2]
[2,3,3,4,4,5]
ghci&gt; [1, 2] &lt;**&gt; [(+1), (+2), (+3)]
[2,3,4,3,4,5]
ghci&gt; flip(&lt;*&gt;) [1, 2] [(+1), (+2), (+3)]
[2,3,3,4,4,5]
</code></pre>
<h4 id="when_unless">when &amp; unless<a class="headerlink" href="#when_unless" title="Permanent link">#</a></h4>
<p style="text-align: center;">when :: Applicative f =&gt; Bool -&gt; f () -&gt; f ()</p>
<p>传入的第一个是一个结果为<span class="heti-skip"><span class="heti-spacing"> </span>Bool<span class="heti-spacing"> </span></span>类型的测试，如果测试为<span><span class="heti-spacing"> </span>True</span>，则调用第二个参数，否则返回<span><span class="heti-spacing"> </span>pure ()</span><heti-adjacent class="heti-adjacent-half">。</heti-adjacent>（<span>when<span class="heti-spacing"> </span></span>函数在上文<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>操作中使用过）</p>
<p><span>unless<span class="heti-spacing"> </span></span>则与<span class="heti-skip"><span class="heti-spacing"> </span>when<span class="heti-spacing"> </span></span>相反，测试为<span class="heti-skip"><span class="heti-spacing"> </span>True<span class="heti-spacing"> </span></span>返回<span><span class="heti-spacing"> </span>pure ()</span></p>
<h4 id="sequencea">sequenceA<a class="headerlink" href="#sequencea" title="Permanent link">#</a></h4>
<p style="text-align: center;">sequenceA :: (Traversable t, Applicative f) =&gt; t (f a) -&gt; f (t a)</p>
<p>应用在列表上时，它的类型相当于：</p>
<p style="text-align: center;">[f a] -&gt; f [a]</p>
<p>所以在列表上它的使用方法：</p>
<pre><code class="language-haskell">ghci&gt; sequenceA [Just 3, Just 2, Just 1]  
Just [3,2,1]  
ghci&gt; sequenceA [Just 3, Nothing, Just 1]  
Nothing  
ghci&gt; sequenceA [(+3),(+2),(+1)] 3  
[6,5,4]  
ghci&gt; sequenceA [[1,2,3],[4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci&gt; sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]  
[]  
</code></pre>
<p>它在对同一个参数应用不同函数时很有用：</p>
<pre><code class="language-haskell">ghci&gt; map (\f -&gt; f 7) [(&gt;4), (&lt;10), odd]  
[True,True,True]  
ghci&gt; sequenceA [(&gt;4), (&lt;10), odd] 7  
[True,True,True]  
</code></pre>
<hr/>
<h2 id="monad">Monad<a class="headerlink" href="#monad" title="Permanent link">#</a></h2>
<p>单子（Monad）是对<span class="heti-skip"><span class="heti-spacing"> </span>Applicative Functor<span class="heti-spacing"> </span></span>的扩展（但是诞生比<span class="heti-skip"><span class="heti-spacing"> </span>Applicative<span class="heti-spacing"> </span></span>早<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，<span>Functor<span class="heti-spacing"> </span></span>的 <code>&lt;$&gt;</code> 函数实现了将普通函数应用在上下文值上，<span>Applicative<span class="heti-spacing"> </span></span>的 <code>&lt;*&gt;</code> 函数将上下文中函数应用在上下文值上。而<span class="heti-skip"><span class="heti-spacing"> </span>Monad<span class="heti-spacing"> </span></span>提供了一个函数 <code>&gt;&gt;=</code>（bind<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，将一个接收普通值返回上下文值的函数应用在上下文值上：</p>
<pre><code class="language-haskell">class Applicative m =&gt; Monad m where
    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b
    (&gt;&gt;) :: m a -&gt; m b -&gt; m b
    return :: a -&gt; m a
    m &gt;&gt; n = m &gt;&gt;= \_ -&gt; n
    return = pure
</code></pre>
<ul>
<li><code>return</code> 函数：和 <code>pure</code> 一样，只是有另一个名字</li>
<li><code>&gt;&gt;</code> 函数：提供了默认的实现方法，它的作用和<span class="heti-skip"><span class="heti-spacing"> </span>Applicative<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>*&gt;<span class="heti-spacing"> </span></span>函数一样</li>
<li><code>&gt;&gt;=</code> 函数（bind<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：比<span class="heti-skip"><span class="heti-spacing"> </span>Applicative<span class="heti-spacing"> </span></span>升级的函数，第一个参数是一个单子，第二个参数是一个接收值返回单子的函数，将这个函数应用在第一个参数单子中的值上，并返回得到的新单子</li>
</ul>
<h3 id="monad_1"><span>Monad<span class="heti-spacing"> </span></span>实例<a class="headerlink" href="#monad_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<h4 id="maybe_2">Maybe<a class="headerlink" href="#maybe_2" title="Permanent link">#</a></h4>
<p><span>Maybe<span class="heti-spacing"> </span></span>是一个单子实例，<span>Applicative<span class="heti-spacing"> </span></span>已经为它实现了<span><span class="heti-spacing"> </span>return</span>，因此只需要<span class="heti-skip"><span class="heti-spacing"> </span>&gt;&gt;=<span class="heti-spacing"> </span></span>函数：</p>
<pre><code class="language-haskell">instance Monad Maybe where
    (Just x) &gt;&gt;= f = f x 
    Nothing  &gt;&gt;= _ = Nothing
</code></pre>
<p>根据定义就很容易实现<span class="heti-skip"><span class="heti-spacing"> </span>Maybe<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>&gt;&gt;=<span class="heti-spacing"> </span></span>函数了，而且也很好理解</p>
<pre><code class="language-haskell">ghci&gt; Just 1 &gt;&gt;= \x -&gt; Just (x + 1)
Just 2
ghci&gt; Just 1 &gt;&gt;= \x -&gt; return (x + 1)
Just 2
ghci&gt; Nothing &gt;&gt;= \x -&gt; Just (x + 1)
Nothing
ghci&gt; Just 1 &gt;&gt;= \x -&gt; Just (x + 1) &gt;&gt; Nothing &gt;&gt;= \y -&gt; Just (y + 1)
Nothing
</code></pre>
<p>最后一个例子中出现了<span><span class="heti-spacing"> </span>&gt;&gt; Nothing</span>，这时<span class="heti-skip"><span class="heti-spacing"> </span>Nothing<span class="heti-spacing"> </span></span>前的部分全都相当于没用，因为<span class="heti-skip"><span class="heti-spacing"> </span>&gt;&gt;<span class="heti-spacing"> </span></span>操作符的左右两边只要有一个出现<span><span class="heti-spacing"> </span>Nothing</span>，那整体就会是<span><span class="heti-spacing"> </span>Nothing</span>。这个特性可以用于在中途随时判断失误，只要有一处失误，结果就会是<span><span class="heti-spacing"> </span>Nothing</span></p>
<h4 id="_17">[]<a class="headerlink" href="#_17" title="Permanent link">#</a></h4>
<p>列表也是一个单子：</p>
<pre><code class="language-haskell">instance Monad [] where
    xs &gt;&gt;= f = concat (map f xs)
</code></pre>
<p>将这个函数应用在<span class="heti-skip"><span class="heti-spacing"> </span>xs<span class="heti-spacing"> </span></span>的每个值上，将返回的所有列表平铺成一个列表：</p>
<pre><code class="language-haskell">ghci&gt; [3,4,5] &gt;&gt;= \x -&gt; [x,-x]  
[3,-3,4,-4,5,-5]  
ghci&gt; [1,2] &gt;&gt;= \n -&gt; ['a','b'] &gt;&gt;= \ch -&gt; return (n,ch)  
[(1,'a'),(1,'b'),(2,'a'),(2,'b')]  
</code></pre>
<h4 id="io_3">IO<a class="headerlink" href="#io_3" title="Permanent link">#</a></h4>
<p><span>IO<span class="heti-spacing"> </span></span>也是一个单子，但是实现方法比较深奥（逃</p>
<h4 id="-_r_2">(-&gt;) r<a class="headerlink" href="#-_r_2" title="Permanent link">#</a></h4>
<p><span>(-&gt;) r<span class="heti-spacing"> </span></span>也是一个单子，和<span><span class="heti-spacing"> </span>Functor</span>、<span>Applicative<span class="heti-spacing"> </span></span>一样，先分析它的<span class="heti-skip"><span class="heti-spacing"> </span>&gt;&gt;=<span class="heti-spacing"> </span></span>类型签名：</p>
<p style="text-align: center;">(&gt;&gt;=) :: (-&gt; r) a -&gt; (a -&gt; (-&gt; r) b) -&gt; (-&gt; r) b</p>
<p style="text-align: center;">(&gt;&gt;=) :: (r -&gt; a) -&gt; (a -&gt; r -&gt; b) -&gt; (r -&gt; b)</p>
<p>也可以看出来，它接收两个函数<span><span class="heti-spacing"> </span>f :: r -&gt; a</span>、g :: a -&gt; r -&gt; b，然后返回一个新的函数<span><span class="heti-spacing"> </span>h :: r -&gt; b</span></p>
<p>那么函数<span class="heti-skip"><span class="heti-spacing"> </span>h<span class="heti-spacing"> </span></span>接收一个类型为<span class="heti-skip"><span class="heti-spacing"> </span>r<span class="heti-spacing"> </span></span>的参数，返回一个类型为<span class="heti-skip"><span class="heti-spacing"> </span>b<span class="heti-spacing"> </span></span>的值。所以先对输入应用<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>得到类型为<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>的中间值，然后再将这个值和输入参数一起传入函数<span class="heti-skip"><span class="heti-spacing"> </span>g<span class="heti-spacing"> </span></span>得到结果。所以函数<span class="heti-skip"><span class="heti-spacing"> </span>h<span class="heti-spacing"> </span></span>的定义应该是：</p>
<p style="text-align: center;">\x -&gt; g (f x) x</p>
<pre><code class="language-haskell">instance Monad ((-&gt;) r) where
    f &gt;&gt;= g = \x -&gt; g (f x) x
</code></pre>
<pre><code class="language-haskell">ghci&gt; (+3) &gt;&gt;= (+) $ 1
5
ghci&gt; (+) &lt;$&gt; (+3) &lt;*&gt; id $ 1
5
</code></pre>
<h3 id="do-notation">do-notation<a class="headerlink" href="#do-notation" title="Permanent link">#</a></h3>
<p><span>Haskell<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>do<span class="heti-spacing"> </span></span>语句为链式的<span class="heti-skip"><span class="heti-spacing"> </span>&gt;&gt;=<span class="heti-spacing"> </span></span>应用提供了类似命令式（imperative style）的语法糖。比如 <code>a &gt;&gt;= \x -&gt; b &gt;&gt; c &gt;&gt;= \y -&gt; d</code>：</p>
<pre><code class="language-haskell">a &gt;&gt;= \x -&gt;
b &gt;&gt;
c &gt;&gt;= \y -&gt;
d
</code></pre>
<p>其中有<span class="heti-skip"><span class="heti-spacing"> </span>abcd<span class="heti-spacing"> </span></span>四个值，可以看出<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>中内容绑定到了<span class="heti-skip"><span class="heti-spacing"> </span>x<span class="heti-spacing"> </span></span>上，<span>c<span class="heti-spacing"> </span></span>中内容绑定到了<span class="heti-skip"><span class="heti-spacing"> </span>y<span class="heti-spacing"> </span></span>上。使用<span class="heti-skip"><span class="heti-spacing"> </span>do<span class="heti-spacing"> </span></span>语句来表示这个操作可以写成：</p>
<pre><code class="language-haskell">do { x &lt;- a 
   ;      b 
   ; y &lt;- c 
   ;      d 
   }
</code></pre>
<p>其中的大括号和分号可以省略不写（挤在一行时不能省略<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。<span>do<span class="heti-spacing"> </span></span>语句也只是一个语法糖，它可以递归地转换成普通的<span class="heti-skip"><span class="heti-spacing"> </span>Monad<span class="heti-spacing"> </span></span>操作语句：</p>
<ul>
<li><code>do e</code>：e</li>
<li><code>do { e; ... }</code>：e &gt;&gt; do { ... }</li>
<li><code>do { v &lt;- e; ... }</code>：e &gt;&gt;= \v -&gt; do { ... }</li>
<li><code>do { let ...; ... }</code>：let ... in do { ... }</li>
</ul>
<h4 id="applicativedo">ApplicativeDo<a class="headerlink" href="#applicativedo" title="Permanent link">#</a></h4>
<p>比如如下一个<span class="heti-skip"><span class="heti-spacing"> </span>do<span class="heti-spacing"> </span></span>语句：</p>
<pre><code class="language-haskell">do x &lt;- a 
   y &lt;- b 
   z &lt;- c 
   return (f x y z)
</code></pre>
<p>它可以转化成：</p>
<p style="text-align: center;">a &gt;&gt;= \x -&gt; b &gt;&gt;= \y -&gt; c &gt;&gt;= \z -&gt; return (f x y z)</p>
<p>但是经过观察可以发现，整个语句实际上将函数<span class="heti-skip"><span class="heti-spacing"> </span>f<span class="heti-spacing"> </span></span>应用在了三个上下文中的值上，所以仅用<span class="heti-skip"><span class="heti-spacing"> </span>Applicative<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>&lt;$&gt;<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>&lt;*&gt;<span class="heti-spacing"> </span></span>完全可以实现：</p>
<p style="text-align: center;">f  a  b  c</p>
<p>而且在运行的时候<span class="heti-skip"><span class="heti-spacing"> </span>Applicative<span class="heti-spacing"> </span></span>的效率会比<span class="heti-skip"><span class="heti-spacing"> </span>Monad<span class="heti-spacing"> </span></span>高，所以<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>会将<span class="heti-skip"><span class="heti-spacing"> </span>do<span class="heti-spacing"> </span></span>语句尽可能优先转换为<span class="heti-skip"><span class="heti-spacing"> </span>Applicative<span class="heti-spacing"> </span></span>的表示方法然后再计算</p>
<h3 id="monad_laws">Monad Laws<a class="headerlink" href="#monad_laws" title="Permanent link">#</a></h3>
<ol>
<li><code>Left identity</code>：return a &gt;&gt;= k      = k a</li>
<li><code>Right identity</code>：m        &gt;&gt;= return = m</li>
<li><code>Associativity</code>：(m &gt;&gt;= g) &gt;&gt;= h      = m &gt;&gt;= (\x -&gt; g x &gt;&gt;= h)</li>
</ol>
<p>前两个定律很好理解：</p>
<ul>
<li>将<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>注入上下文之后绑定（bind）给函数<span><span class="heti-spacing"> </span>k(:: a -&gt; m a)</span>，相当于直接将<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>直接传入函数<span><span class="heti-spacing"> </span>k</span></li>
<li>将已经包含在上下文中的值绑定给<span class="heti-skip"><span class="heti-spacing"> </span>return<span class="heti-spacing"> </span></span>函数，相当于保持不变</li>
</ul>
<p>第三个定律是结合律，把它写成更像结合律的表示方法是：</p>
<p style="text-align: center;">(m &gt;&gt;= (\x -&gt; g x)) &gt;&gt;= h <code>=</code> m &gt;&gt;= (\x -&gt; g x &gt;&gt;= h)</p>
<h4 id="_18">组合运算符（&gt;=&gt;）形式<a class="headerlink" href="#_18" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p><code>Control.Monad</code> 模块中还定义了函数 <code>&gt;=&gt;</code>（Kleisli-composition operator<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<pre><code class="language-haskell">infixr 1 &gt;=&gt;
(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; (a -&gt; m c)
f &gt;=&gt; g = \x -&gt; f x &gt;&gt;= g
</code></pre>
<p>使用<span class="heti-skip"><span class="heti-spacing"> </span>&gt;=&gt;<span class="heti-spacing"> </span></span>运算符可以将两个用于绑定的函数结合在一起。用它表示的<span class="heti-skip"><span class="heti-spacing"> </span>Monad<span class="heti-spacing"> </span></span>定律更加清晰直观：</p>
<ol>
<li><code>Left identity</code>：return &gt;=&gt; f = f</li>
<li><code>Right identity</code>：f &gt;=&gt; return = f</li>
<li><code>Associativity</code>：(f &gt;=&gt; g) &gt;=&gt; h = f &gt;=&gt; (g &gt;=&gt; h)</li>
</ol>
<h4 id="do-notation_1"><span>do-notation<span class="heti-spacing"> </span></span>形式<a class="headerlink" href="#do-notation_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p><span>Monad<span class="heti-spacing"> </span></span>的这三个定律还可以使用<span class="heti-skip"><span class="heti-spacing"> </span>do<span class="heti-spacing"> </span></span>语句来描述：</p>
<ol>
<li><code>Left identity</code>：
    <code>haskell
    do { x' &lt;- return x;
         f x'             =   do { f x } 
       }</code></li>
<li><code>Right identity</code>：
    <code>haskell
    do { x &lt;- m; 
         return x         =   do { m }
       }</code></li>
<li><code>Associativity</code>：
    <code>haskell
    do { y &lt;- do { x &lt;- m;       do { x &lt;- m;              do { x &lt;- m;
                   f x                do { y &lt;- f x;            y &lt;- f x;
                 }           =             g y         =        g y
         g y                             }                    }
       }                            }</code></li>
</ol>
<h3 id="intuition_2">Intuition<a class="headerlink" href="#intuition_2" title="Permanent link">#</a></h3>
<p><span>Monad<span class="heti-spacing"> </span></span>也可以很自然地看成<span class="heti-skip"><span class="heti-spacing"> </span>Applicative<span class="heti-spacing"> </span></span>的升级版，比如<span class="heti-skip"><span class="heti-spacing"> </span>Applicative<span class="heti-spacing"> </span></span>的操作全部是固定的，而<span class="heti-skip"><span class="heti-spacing"> </span>Monad<span class="heti-spacing"> </span></span>的操作可以在中途突然改变</p>
<p>同时<span class="heti-skip"><span class="heti-spacing"> </span>Monad<span class="heti-spacing"> </span></span>也完成了<span class="heti-skip"><span class="heti-spacing"> </span>Functor<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>Applicative<span class="heti-spacing"> </span></span>无法完成的操作。比如要用<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>和实现<span class="heti-skip"><span class="heti-spacing"> </span>&gt;&gt;=<span class="heti-spacing"> </span></span>函数（即达成操作<span><span class="heti-spacing"> </span>m a -&gt; (a -&gt; m b) -&gt; m b</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，先假设<span><span class="heti-spacing"> </span>f :: a -&gt; m b</span>，那么<span class="heti-skip"><span class="heti-spacing"> </span>fmap f<span class="heti-spacing"> </span></span>的类型就会是<span><span class="heti-spacing"> </span>m a -&gt; m (m b)</span>，将<span class="heti-skip"><span class="heti-spacing"> </span>m a<span class="heti-spacing"> </span></span>应用在<span class="heti-skip"><span class="heti-spacing"> </span>fmap f<span class="heti-spacing"> </span></span>上会得到结果<span><span class="heti-spacing"> </span>m (m b)</span>，而不是<span><span class="heti-spacing"> </span>m b</span>。但是目前只可以使用<span class="heti-skip"><span class="heti-spacing"> </span>pure<span class="heti-spacing"> </span></span>将一个值装入上下文中（a -&gt; m a<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，而没有一个函数可以从上下文中提取值（m a -&gt; a<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。那么就需要定义一个新的函数来实现这个操作的效果（m (m b) -&gt; m b<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。因此<span class="heti-skip"><span class="heti-spacing"> </span>Monad<span class="heti-spacing"> </span></span>的另一个等效的定义方法是：</p>
<pre><code class="language-haskell">class Applicative m =&gt; Monad' m where
    join :: m (m a) -&gt; m a 

    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b 
    x &gt;&gt;= f = join $ fmap f x
</code></pre>
<p>但是定义<span class="heti-skip"><span class="heti-spacing"> </span>&gt;&gt;=<span class="heti-spacing"> </span></span>函数会更为直观方便，所以<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>采用了用<span class="heti-skip"><span class="heti-spacing"> </span>&gt;&gt;=<span class="heti-spacing"> </span></span>函数定义<span class="heti-skip"><span class="heti-spacing"> </span>Monad<span class="heti-spacing"> </span></span>的方法</p>
<p>同时<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>还提供了<span class="heti-skip"><span class="heti-spacing"> </span>join<span class="heti-spacing"> </span></span>函数的定义：</p>
<pre><code class="language-haskell">join :: Monad m =&gt; m (m a) -&gt; m a 
join x = x &gt;&gt;= id
</code></pre>
<h3 id="_19">常用函数<a class="headerlink" href="#_19" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<h4 id="liftm_ap">liftM &amp; ap<a class="headerlink" href="#liftm_ap" title="Permanent link">#</a></h4>
<p style="text-align: center;">liftM :: Monad m =&gt; (a -&gt; b) -&gt; m a -&gt; m b</p>
<p style="text-align: center;">ap :: Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b</p>
<p>所以<span class="heti-skip"><span class="heti-spacing"> </span>liftM<span class="heti-spacing"> </span></span>其实就是<span><span class="heti-spacing"> </span>fmap</span>、<span>ap<span class="heti-spacing"> </span></span>就是<span><span class="heti-spacing"> </span>&lt;*&gt;</span>，但是老版本的<span class="heti-skip"><span class="heti-spacing"> </span>GHC<span class="heti-spacing"> </span></span>定义<span class="heti-skip"><span class="heti-spacing"> </span>Monad<span class="heti-spacing"> </span></span>并没有<span><span class="heti-spacing"> </span>Functor</span>、<span>Applicative<span class="heti-spacing"> </span></span>的约束，所以实现了<span><span class="heti-spacing"> </span>liftM</span>、ap，并且保留了这个名字</p>
<p>因此一个单子也可以通过 <code>pure = return</code>、<code>(&lt;*&gt;) = ap</code> 直接成为应用函子的实例</p>
<h4 id="sequence_1">sequence<a class="headerlink" href="#sequence_1" title="Permanent link">#</a></h4>
<p style="text-align: center;">sequence :: Monad m =&gt; [m a] -&gt; m [a]</p>
<p><span>sequence<span class="heti-spacing"> </span></span>的作用显而易见，而且在<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>部分也使用到了。但是这个版本是在 <code>GHC.Base</code> 模块中定义的，还有一个更广泛的使用<span class="heti-skip"><span class="heti-spacing"> </span>Traversable<span class="heti-spacing"> </span></span>的定义在 <code>Data.Traversable</code> 模块中 </p>
<h4 id="replicatem">replicateM<a class="headerlink" href="#replicatem" title="Permanent link">#</a></h4>
<p style="text-align: center;">replicateM :: Applicative m =&gt; Int -&gt; m a -&gt; m [a]</p>
<h4 id="mapm_form">mapM &amp; forM<a class="headerlink" href="#mapm_form" title="Permanent link">#</a></h4>
<p style="text-align: center;">mapM :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]</p>
<p style="text-align: center;">forM :: Monad m =&gt; [a] -&gt; (a -&gt; m b) -&gt; m [b]</p>
<p><span>forM<span class="heti-spacing"> </span></span>的用法在<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>部分已经说过，<span>mapM<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>forM<span class="heti-spacing"> </span></span>都在 <code>Data.Traversable</code> 模块中有广泛版本</p>
<p>还有一些其他的函数：filterM、zipWithM、foldM、forever，通过名字就可以看出用法，是将原来仅使用与列表的函数提升至可以适用于所有单子</p>
<p>并且在函数名后加下划线，比如<span><span class="heti-spacing"> </span>sequence_</span>、mapM_，会忽略返回值（最终结果为 <code>m ()</code>）</p>
<h4 id="_20">=&lt;&lt; &amp; &gt;=&gt; &amp; &lt;=&lt;<a class="headerlink" href="#_20" title="Permanent link">#</a></h4>
<p>（<code>&gt;=&gt;</code> 操作符在上面<a href="#_18"><span class="heti-skip"><span class="heti-spacing"> </span>Monad Laws<span class="heti-spacing"> </span></span></a>部分已经给出了定义）
- x &gt;&gt;= f = f =&lt;&lt; x 
- f &gt;=&gt; g = g &lt;=&lt; f </p>
<hr/>
<h2 id="monadfail">MonadFail<a class="headerlink" href="#monadfail" title="Permanent link">#</a></h2>
<p><span>MonadFail<span class="heti-spacing"> </span></span>定义在 <code>Control.Monad.Fail</code> 模块中：</p>
<pre><code class="language-haskell">class Monad m =&gt; MonadFail m where
    fail :: String -&gt; m a 
</code></pre>
<p>它只要求在<span class="heti-skip"><span class="heti-spacing"> </span>Monad<span class="heti-spacing"> </span></span>的基础上实现<span class="heti-skip"><span class="heti-spacing"> </span>fail<span class="heti-spacing"> </span></span>函数，接收一个字符串返回一个单子。这会使在<span class="heti-skip"><span class="heti-spacing"> </span>do<span class="heti-spacing"> </span></span>语句中产生错误时直接变为错误值（空值）使最终的返回值为错误值</p>
<h3 id="monadfail_1"><span>MonadFail<span class="heti-spacing"> </span></span>实例<a class="headerlink" href="#monadfail_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<pre><code class="language-haskell">instance MonadFail Maybe where
    fail _ = Nothing

instance MonadFail [] where
    fail _ = []

instance MonadFail IO where
    fail = failIO
</code></pre>
<p><span>Maybe<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>[]<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>fail<span class="heti-spacing"> </span></span>函数都与第一个参数无关，直接返回空值（Nothing、[]<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>；而<span class="heti-skip"><span class="heti-spacing"> </span>IO<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>fail<span class="heti-spacing"> </span></span>函数直接使用<span><span class="heti-spacing"> </span>failIO</span>，实现方法也是深奥（接着逃</p>
<pre><code class="language-haskell">exampleFail :: Maybe Char 
exampleFail = do
    (x:xs) &lt;- Just ""
    return x 

ghci&gt; exampleFail
Nothing
</code></pre>
<p>在这个例子的<span class="heti-skip"><span class="heti-spacing"> </span>do<span class="heti-spacing"> </span></span>语句中，在提取<span class="heti-skip"><span class="heti-spacing"> </span>Just ""<span class="heti-spacing"> </span></span>中的值时用了模式匹配，但是因为其内容为空字符串，<span>x:xs<span class="heti-spacing"> </span></span>匹配会出现错误，这时就会触发<span class="heti-skip"><span class="heti-spacing"> </span>fail<span class="heti-spacing"> </span></span>函数直接返回<span><span class="heti-spacing"> </span>Nothing</span></p>
<h3 id="monadfail_law">MonadFail Law<a class="headerlink" href="#monadfail_law" title="Permanent link">#</a></h3>
<ul>
<li>fail s &gt;&gt;= m = fail s </li>
</ul>
<hr/>
<h2 id="semigroup">Semigroup<a class="headerlink" href="#semigroup" title="Permanent link">#</a></h2>
<p>半群（semigroup）是一个集合<span><span class="heti-spacing"> </span>$S$</span>，它需要指定一个二元运算符<span><span class="heti-spacing"> </span>$\oplus$</span>，并且满足</p>
<p>$$
a\oplus b \in S\quad a, b\in S
$$</p>
<p>以及结合（associative）律：</p>
<p>$$
(a\oplus b)\oplus c = a\oplus (b\oplus c)
$$</p>
<p>这个二元运算符在<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>Semigroup<span class="heti-spacing"> </span></span>中被定义为 <code>&lt;&gt;</code> 函数：</p>
<pre><code class="language-haskell">class Semigroup a where
    (&lt;&gt;) :: a -&gt; a -&gt; a 

    sconcat :: NonEmpty a -&gt; a 
    sconcat (a :| as) = go a as where 
        go b (c:cs) = b &lt;&gt; go c cs 
        go b []     = b

    stimes :: Integarl b =&gt; b -&gt; a -&gt; a 
    stimes = ...
</code></pre>
<p>除此之外还有 <code>sconcat</code> 和 <code>stimes</code> 函数，都给出了默认实现。对于列表，<span>&lt;&gt;<span class="heti-spacing"> </span></span>相当于<span><span class="heti-spacing"> </span>(++)</span>，<span>stimes<span class="heti-spacing"> </span></span>相当于<span><span class="heti-spacing"> </span>concat . replicate</span>：</p>
<pre><code class="language-haskell">ghci&gt; [1, 2] &lt;&gt; [3, 4]
[1,2,3,4]
ghci&gt; sconcat $ fromList [[1, 2], [3, 4]]
[1,2,3,4]
ghci&gt; stimes 3 [1, 2]
[1,2,1,2,1,2]
</code></pre>
<h3 id="semigroup_law">Semigroup Law<a class="headerlink" href="#semigroup_law" title="Permanent link">#</a></h3>
<ul>
<li>(x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z)</li>
</ul>
<h3 id="nonempty">补：NonEmpty<a class="headerlink" href="#nonempty" title="Permanent link">#</a></h3>
<p><span>NonEmpty<span class="heti-spacing"> </span></span>表示非空列表，定义是：</p>
<pre><code class="language-haskell">data NonEmpty a = a :| [a] deriving (Eq, Ord)
</code></pre>
<p>使用一个元素和一个列表用 <code>:|</code> 连接就可以生成一个<span class="heti-skip"><span class="heti-spacing"> </span>NonEmpty<span class="heti-spacing"> </span></span>类型的列表</p>
<p><code>Data.List.NonEmpty</code> 模块中实现了很多普通列表有的函数，需要<span class="heti-skip"><span class="heti-spacing"> </span>qualified import<span class="heti-spacing"> </span></span>后调用，使用<span><span class="heti-spacing"> </span>fromList</span>、<span>toList<span class="heti-spacing"> </span></span>函数可以在普通列表和非空列表之间转换</p>
<pre><code class="language-haskell">ghci&gt; import qualified Data.List.NonEmpty as NE
ghci&gt; arr = NE.fromList [1, 2, 3]
ghci&gt; arr
1 :| [2,3]
ghci&gt; NE.head arr 
1
ghci&gt; NE.tail arr 
[2,3]
</code></pre>
<hr/>
<h2 id="monoid">Monoid<a class="headerlink" href="#monoid" title="Permanent link">#</a></h2>
<p>幺半群（Monoid）是一个有单位元素<span class="heti-skip"><span class="heti-spacing"> </span>$e$<span class="heti-spacing"> </span></span>的半群，即<span class="heti-skip"><span class="heti-spacing"> </span>$e$<span class="heti-spacing"> </span></span>满足：</p>
<p>$$
e\oplus x = x\oplus e = x
$$</p>
<pre><code class="language-haskell">class Semigroup a =&gt; Monoid a where 
    mempty  :: a 

    mappend :: a -&gt; a -&gt; a 
    mappend = (&lt;&gt;)

    mconcat :: [a] -&gt; a 
    mconcat = foldr mappend mempty 
</code></pre>
<p>可以看出<span class="heti-skip"><span class="heti-spacing"> </span>Monoid<span class="heti-spacing"> </span></span>要求了三个函数，其中最少只需要 <code>mempty</code>，它直接返回一个值，表示单位元素。<code>mappend</code> 即<span class="heti-skip"><span class="heti-spacing"> </span>Semigroup<span class="heti-spacing"> </span></span>中的<span class="heti-skip"><span class="heti-spacing"> </span>&lt;&gt;<span class="heti-spacing"> </span></span>运算符，<code>mconcat</code> 也提供了默认实现</p>
<h3 id="monoid_1"><span>Monoid<span class="heti-spacing"> </span></span>实例<a class="headerlink" href="#monoid_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h3>
<h4 id="a_1">[a]<a class="headerlink" href="#a_1" title="Permanent link">#</a></h4>
<p>因为<span class="heti-skip"><span class="heti-spacing"> </span>Monoid<span class="heti-spacing"> </span></span>的实例是一个具体类型，而不是像<span class="heti-skip"><span class="heti-spacing"> </span>Functor<span class="heti-spacing"> </span></span>等一样等类型构造器，所以<span class="heti-skip"><span class="heti-spacing"> </span>[]<span class="heti-spacing"> </span></span>并不是<span class="heti-skip"><span class="heti-spacing"> </span>Monoid<span class="heti-spacing"> </span></span>的实例，但是具体类型<span class="heti-skip"><span class="heti-spacing"> </span>[a]<span class="heti-spacing"> </span></span>是一个幺半群：</p>
<pre><code class="language-haskell">instance Semigroup [a] where 
    (&lt;&gt;) = (++)

instance Monoid [a] where 
    mempty = [] 
    mconcat xss = [x | xs &lt;- xss, x &lt;- xs]
</code></pre>
<p>列表的单位元素（mempty）就是空列表<span><span class="heti-spacing"> </span>[]</span>，运算符就是合并列表<span><span class="heti-spacing"> </span>(++)</span>，<span>mconcat<span class="heti-spacing"> </span></span>也用列表推导重新实现提高效率</p>
<pre><code class="language-haskell">ghci&gt; mempty :: [Int] 
[]
ghci&gt; [1, 2] &lt;&gt; [3, 4]
[1,2,3,4]
ghci&gt; [1, 2] `mappend` [3, 4]
[1,2,3,4]
ghci&gt; mconcat [[1,2], [3,4]]
[1,2,3,4]
</code></pre>
<h4 id="ordering">Ordering<a class="headerlink" href="#ordering" title="Permanent link">#</a></h4>
<pre><code class="language-haskell">instance Semigroup Ordering where
    LT &lt;&gt; _ = LT
    EQ &lt;&gt; y = y
    GT &lt;&gt; _ = GT

instance Monoid Ordering where
    mempty = EQ
</code></pre>
<p>主要可以用于比较字典序：</p>
<pre><code class="language-haskell">ghci&gt; mconcat (zipWith compare "abcd" "acbd")
LT
</code></pre>
<h4 id="sum_product">Sum &amp; Product<a class="headerlink" href="#sum_product" title="Permanent link">#</a></h4>
<p>对于数字，加法和乘法都满足结合律，所以对于<span><span class="heti-spacing"> </span>Num</span>，有两种实现<span class="heti-skip"><span class="heti-spacing"> </span>Monoid<span class="heti-spacing"> </span></span>的方式，但是不能为同一类型设置两种实例方式，所以 <code>Data.Monoid</code> 中提供了两个包装器———— <span>Sum<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>Product</span>：</p>
<pre><code class="language-haskell">newtype Sum a = Sum {getSum :: a} deriving (...)
newtype Product a = Product {getProduct :: a} deriving (...)
</code></pre>
<p>它们使用<span class="heti-skip"><span class="heti-spacing"> </span>Sum<span class="heti-spacing"> </span></span>或<span class="heti-skip"><span class="heti-spacing"> </span>Product<span class="heti-spacing"> </span></span>来包装起一个数字，可以通过<span class="heti-skip"><span class="heti-spacing"> </span>getSum<span class="heti-spacing"> </span></span>或<span class="heti-skip"><span class="heti-spacing"> </span>getProduct<span class="heti-spacing"> </span></span>来获取其中的值</p>
<p>对于加法，二元操作为<span><span class="heti-spacing"> </span>(+)</span>，单位元素为<span><span class="heti-spacing"> </span>0</span>；对于乘法，二元操作为<span><span class="heti-spacing"> </span>(*)</span>，单位元素为<span><span class="heti-spacing"> </span>1:</span></p>
<pre><code class="language-haskell">instance Num a =&gt; Semigroup (Sum a) where
    (&lt;&gt;) = coerce ((+) :: a -&gt; a -&gt; a)

instance Num a =&gt; Monoid (Sum a) where
    mempty = Sum 0

instance Num a =&gt; Semigroup (Product a) where
    (&lt;&gt;) = coerce ((*) :: a -&gt; a -&gt; a)

instance Num a =&gt; Monoid (Product a) where
    mempty = Product 1
</code></pre>
<pre><code class="language-haskell">ghci&gt; Sum 5 &lt;&gt; Sum 6 &lt;&gt; Sum 10
Sum {getSum = 21}
ghci&gt; getSum . mconcat . fmap Sum $ [5, 6, 10]
21
ghci&gt; Product 5 &lt;&gt; Product 6 &lt;&gt; Product 10
Product {getProduct = 300}
ghci&gt; getProduct . mconcat . fmap Product $ [5, 6, 10]
300
</code></pre>
<h4 id="all_any">All &amp; Any<a class="headerlink" href="#all_any" title="Permanent link">#</a></h4>
<p>和数字一样，布尔值也有两种实现<span class="heti-skip"><span class="heti-spacing"> </span>Monoid<span class="heti-spacing"> </span></span>的方式，因此 <code>Data.Monoid</code> 模块中也提供了两个包装器，分别实现了这两种<span><span class="heti-spacing"> </span>Monoid</span>：</p>
<pre><code class="language-haskell">newtype All = All { getAll :: Bool } deriving (...)

instance Semigroup All where
        (&lt;&gt;) = coerce (&amp;&amp;)

instance Monoid All where
        mempty = All True


newtype Any = Any { getAny :: Bool } deriving (...)

instance Semigroup Any where
        (&lt;&gt;) = coerce (||)

instance Monoid Any where
        mempty = Any False
</code></pre>
<pre><code class="language-haskell">ghci&gt; getAll (All True &lt;&gt; mempty &lt;&gt; All False)
False
ghci&gt; getAll (mconcat (map (\x -&gt; All (even x)) [2,4,6,7,8]))
False
ghci&gt; getAny (Any True &lt;&gt; mempty &lt;&gt; Any False)
True
ghci&gt; getAny (mconcat (map (\x -&gt; Any (even x)) [2,4,6,7,8]))
True
</code></pre>
<h4 id="monoid_a_maybe_a">Monoid a =&gt; Maybe a<a class="headerlink" href="#monoid_a_maybe_a" title="Permanent link">#</a></h4>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>是一个<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>幺<span class="heti-skip"><span class="heti-spacing"> </span>)<span class="heti-spacing"> </span></span>半群，那么<span class="heti-skip"><span class="heti-spacing"> </span>Maybe a<span class="heti-spacing"> </span></span>也是一个幺半群，单位元就是<span><span class="heti-spacing"> </span>Nothing</span>：</p>
<pre><code class="language-haskell">instance Semigroup a =&gt; Semigroup (Maybe a) where
    Nothing &lt;&gt; b       = b
    a       &lt;&gt; Nothing = a
    Just a  &lt;&gt; Just b  = Just (a &lt;&gt; b)

instance Semigroup a =&gt; Monoid (Maybe a) where
    mempty = Nothing
</code></pre>
<pre><code class="language-haskell">ghci&gt; Nothing &lt;&gt; Just "andy"
Just "andy"
ghci&gt; Just LT &lt;&gt; Nothing
Just LT
ghci&gt; Just (Sum 3) &lt;&gt; Just (Sum 4) 
Just (Sum {getSum = 7})
</code></pre>
<h4 id="first_last">First &amp; Last<a class="headerlink" href="#first_last" title="Permanent link">#</a></h4>
<p>对于<span class="heti-skip"><span class="heti-spacing"> </span>Maybe<span class="heti-spacing"> </span></span>也有两种实现<span class="heti-skip"><span class="heti-spacing"> </span>Monoid<span class="heti-spacing"> </span></span>的方法，即<span class="heti-skip"><span class="heti-spacing"> </span>&lt;&gt;<span class="heti-spacing"> </span></span>操作每次恒取左边和每次恒取右边（在没有<span class="heti-skip"><span class="heti-spacing"> </span>Nothing<span class="heti-spacing"> </span></span>的情况下<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，所以 <code>Data.Monoid</code> 模块中也提供了两个新的包装器：<span>First<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>Last</span>：</p>
<pre><code class="language-haskell">newtype First a = First { getFirst :: Maybe a } deriving (...)

instance Semigroup (First a) where
    First Nothing &lt;&gt; b = b
    a             &lt;&gt; _ = a

instance Monoid (First a) where
    mempty = First Nothing


newtype Last a = Last { getLast :: Maybe a } deriving (...)

instance Semigroup (Last a) where
    a &lt;&gt; Last Nothing = a
    _ &lt;&gt; b            = b

instance Monoid (Last a) where
    mempty = Last Nothing
</code></pre>
<pre><code class="language-haskell">ghci&gt; getFirst (First (Just "hello") &lt;&gt; First Nothing &lt;&gt; First (Just "world"))
Just "hello"
ghci&gt; getLast (Last (Just "hello") &lt;&gt; Last Nothing &lt;&gt; Last (Just "world"))
Just "world"
ghci&gt; getFirst . mconcat . map First $ [Nothing, Just 9, Just 10]  
Just 9
ghci&gt; getLast . mconcat . map Last $ [Nothing, Just 9, Just 10]  
Just 10
</code></pre>
<h4 id="min_max">Min &amp; Max<a class="headerlink" href="#min_max" title="Permanent link">#</a></h4>
<p>对于有界的类型，也有两种实现<span class="heti-skip"><span class="heti-spacing"> </span>Monoid<span class="heti-spacing"> </span></span>的方式，每次二元操作都取最小或最大。<code>Data.Semigroup</code> 模块中提供了两个包装其器：<span>Min<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>Max</span>：</p>
<pre><code class="language-haskell">newtype Min a = Min { getMin :: a } deriving (...)

instance Ord a =&gt; Semigroup (Min a) where
    (&lt;&gt;) = coerce (min :: a -&gt; a -&gt; a)

instance (Ord a, Bounded a) =&gt; Monoid (Min a) where
    mempty = maxBound


newtype Max a = Max { getMax :: a } deriving (...)

instance Ord a =&gt; Semigroup (Max a) where
    (&lt;&gt;) = coerce (max :: a -&gt; a -&gt; a)

instance (Ord a, Bounded a) =&gt; Monoid (Max a) where
    mempty = minBound
</code></pre>
<pre><code class="language-haskell">ghci&gt; Min 3 &lt;&gt; Min 5
Min {getMin = 3}
ghci&gt; Max 3 &lt;&gt; Max 5
Max {getMax = 5}
ghci&gt; getMin . mconcat . map Min $ [1,2,3] :: Int
1
ghci&gt; getMax . mconcat . map Max $ [1,2,3] :: Int
3
</code></pre>
<h4 id="_21">元组<a class="headerlink" href="#_21" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p>当元组内的所有元素都是幺半群时，整个元组也是一个幺半群：</p>
<pre><code class="language-haskell">instance (Semigroup a, Semigroup b) =&gt; Semigroup (a, b) where
        (a,b) &lt;&gt; (a',b') = (a&lt;&gt;a',b&lt;&gt;b')
        stimes n (a,b) = (stimes n a, stimes n b)

instance (Monoid a, Monoid b) =&gt; Monoid (a,b) where
        mempty = (mempty, mempty)
</code></pre>
<pre><code class="language-haskell">ghci&gt; mconcat $ map (\x -&gt; (Min x, Max x)) [1..10] :: (Min Int, Max Int)
(Min {getMin = 1},Max {getMax = 10})
</code></pre>
<h3 id="monoid_laws">Monoid Laws<a class="headerlink" href="#monoid_laws" title="Permanent link">#</a></h3>
<ul>
<li>mempty &lt;&gt; x = x</li>
<li>x &lt;&gt; mempty = x</li>
<li>(x &lt;&gt; y) &lt;&gt; z = x &lt;&gt; (y &lt;&gt; z)</li>
</ul>
<hr/>
<h2 id="monoidal_classes">Monoidal classes<a class="headerlink" href="#monoidal_classes" title="Permanent link">#</a></h2>
<p>Applicative、Monad、<span>Arrow<span class="heti-spacing"> </span></span>都有有幺半群性质的子类型类，分别是<span><span class="heti-spacing"> </span>Alternative</span>、MonadPlus、ArrowPlus</p>
<h3 id="alternative">Alternative<a class="headerlink" href="#alternative" title="Permanent link">#</a></h3>
<pre><code class="language-haskell">class Applicative f =&gt; Alternative f where
    -- | The identity of '&lt;|&gt;'
    empty :: f a
    -- | An associative binary operation
    (&lt;|&gt;) :: f a -&gt; f a -&gt; f a

    some :: f a -&gt; f [a]
    some v = (:) &lt;$&gt; v &lt;*&gt; many v
    many :: f a -&gt; f [a]
    many v = some v &lt;|&gt; pure []
</code></pre>
<p>其中<span class="heti-skip"><span class="heti-spacing"> </span>empty<span class="heti-spacing"> </span></span>是幺半群中的单位元素，<span>&lt;|&gt;<span class="heti-spacing"> </span></span>是幺半群中的二元运算符。<span>some<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>many<span class="heti-spacing"> </span></span>是两个函数（<span>~~<span class="heti-spacing"> </span></span>意义还不懂<span><span class="heti-spacing"> </span>~~</span>）</p>
<h4 id="alternative_1"><span>Alternative<span class="heti-spacing"> </span></span>实例<a class="headerlink" href="#alternative_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<h5 id="_22">[]<a class="headerlink" href="#_22" title="Permanent link">#</a></h5>
<pre><code class="language-haskell">instance Alternative [] where
    empty = []
    (&lt;|&gt;) = (++)
</code></pre>
<p>和<span class="heti-skip"><span class="heti-spacing"> </span>Monoid<span class="heti-spacing"> </span></span>一样，单位元素是空列表，二元运算是列表合并</p>
<pre><code class="language-haskell">ghci&gt; [1,2,3] &lt;|&gt; empty &lt;|&gt; [4,5]
[1,2,3,4,5]
ghci&gt; some []
[]
ghci&gt; many []
[[]]
</code></pre>
<h5 id="maybe_3">Maybe<a class="headerlink" href="#maybe_3" title="Permanent link">#</a></h5>
<pre><code class="language-haskell">instance Alternative Maybe where
    empty = Nothing
    Nothing &lt;|&gt; r = r
    l       &lt;|&gt; _ = l
</code></pre>
<p><span>Maybe<span class="heti-spacing"> </span></span>作为<span class="heti-skip"><span class="heti-spacing"> </span>Alternative<span class="heti-spacing"> </span></span>的单位元素是<span><span class="heti-spacing"> </span>Nothing</span>，二元运算是始终取左边（当左边不为<span class="heti-skip"><span class="heti-spacing"> </span>Nothing<span class="heti-spacing"> </span></span>时）</p>
<pre><code class="language-haskell">ghci&gt; Nothing &lt;|&gt; Just 1 &lt;|&gt; Just 2 
Just 1 
ghci&gt; some Nothing
Nothing 
ghci&gt; many Nothing 
Just []
</code></pre>
<h5 id="ziplist_1">ZipList<a class="headerlink" href="#ziplist_1" title="Permanent link">#</a></h5>
<pre><code class="language-haskell">instance Alternative ZipList where
   empty = ZipList []
   ZipList xs &lt;|&gt; ZipList ys = ZipList (xs ++ drop (length xs) ys)
</code></pre>
<pre><code class="language-haskell">&lt;&gt;getZipList $ ZipList [1,2] &lt;|&gt; ZipList [3,4,5,6]
[1,2,5,6]
&lt;&gt;getZipList $ ZipList [1,2,3,4] &lt;|&gt; ZipList [3,4,5,6]
[1,2,3,4]
</code></pre>
<h4 id="alternative_laws">Alternative Laws<a class="headerlink" href="#alternative_laws" title="Permanent link">#</a></h4>
<ul>
<li><code>Monoid laws</code>:
    <code>haskell 
    empty &lt;|&gt; x = x 
    x &lt;|&gt; empty = x 
    (x &lt;|&gt; y) &lt;|&gt; z = x &lt;|&gt; (y &lt;|&gt; z)</code></li>
<li><code>Left zero law</code>：empty &lt;*&gt; f = empty </li>
</ul>
<p>以上的定律是都满足都，下面的定律只有部分满足：</p>
<ul>
<li><code>Right zero law</code>：f &lt;*&gt; empty = empty （大部分包括<span><span class="heti-spacing"> </span>Maybe</span>、<span>[]<span class="heti-spacing"> </span></span>满足，<span>IO<span class="heti-spacing"> </span></span>不满足）</li>
<li><code>Left distribution</code>：(a &lt;|&gt; b) &lt;<em>&gt; c = (a &lt;</em>&gt; c) &lt;|&gt; (b &lt;*&gt; c) （Maybe、<span>[]<span class="heti-spacing"> </span></span>满足，<span>IO<span class="heti-spacing"> </span></span>及大部分<span class="heti-skip"><span class="heti-spacing"> </span>parsers<span class="heti-spacing"> </span></span>不满足）</li>
<li><code>Right distribution</code>：a &lt;<em>&gt; (b &lt;|&gt; c) = (a &lt;</em>&gt; b) &lt;|&gt; (a &lt;*&gt; c) （大部分不满足，但<span class="heti-skip"><span class="heti-spacing"> </span>Maybe<span class="heti-spacing"> </span></span>满足）</li>
<li><code>Left catch</code>：(pure a) &lt;|&gt; x = pure a （Maybe、IO、<span>parsers<span class="heti-spacing"> </span></span>满足，但<span class="heti-skip"><span class="heti-spacing"> </span>[]<span class="heti-spacing"> </span></span>不满足）</li>
</ul>
<h4 id="_23">常用函数<a class="headerlink" href="#_23" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<ul>
<li><code>asum</code> :: (Foldable t, Alternative f) =&gt; t (f a) -&gt; f a，相当于<span><span class="heti-spacing"> </span>foldr (&lt;|&gt;) empty</span>：
    <code>haskell 
    ghci&gt; asum [Nothing, Just 5, Just 3]
    Just 5
    ghci&gt; asum [[2],[3],[4,5]]
    [2,3,4,5]</code></li>
<li><code>guard</code> :: (Alternative f) =&gt; Bool -&gt; f ()：
    <code>haskell 
    guard True  = pure ()
    guard False = empty</code></li>
</ul>
<h3 id="monadplus">MonadPlus<a class="headerlink" href="#monadplus" title="Permanent link">#</a></h3>
<pre><code class="language-haskell">class (Alternative m, Monad m) =&gt; MonadPlus m where
   mzero :: m a
   mzero = empty

   mplus :: m a -&gt; m a -&gt; m a
   mplus = (&lt;|&gt;)
</code></pre>
<h4 id="monadplus_1"><span>MonadPlus<span class="heti-spacing"> </span></span>实例<a class="headerlink" href="#monadplus_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p>[]、<span>Maybe<span class="heti-spacing"> </span></span>都是<span class="heti-skip"><span class="heti-spacing"> </span>MonadPlus<span class="heti-spacing"> </span></span>的实例，<span>mzero<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>mplus<span class="heti-spacing"> </span></span>都由<span class="heti-skip"><span class="heti-spacing"> </span>Alternative<span class="heti-spacing"> </span></span>实现</p>
<h4 id="monadplus_laws">MonadPlus Laws<a class="headerlink" href="#monadplus_laws" title="Permanent link">#</a></h4>
<ul>
<li><code>Monoid laws</code></li>
<li><code>Left zero</code>：mzero &gt;&gt;= f = mzero</li>
<li><code>Right zero</code>：m &gt;&gt; mzero = mzero </li>
</ul>
<h4 id="_24">常用函数<a class="headerlink" href="#_24" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<ul>
<li><code>msum</code> = asum </li>
<li><code>mfilter</code>：
    <code>haskell 
    mfilter p ma = do
        a &lt;- ma
        if p a then return a else mzero</code></li>
</ul>
<h3 id="arrowplus">ArrowPlus<a class="headerlink" href="#arrowplus" title="Permanent link">#</a></h3>
<p><span>ArrowZero<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>ArrowPlus<span class="heti-spacing"> </span></span>分别为<span class="heti-skip"><span class="heti-spacing"> </span>Arrow<span class="heti-spacing"> </span></span>设置了<span class="heti-skip"><span class="heti-spacing"> </span>Monoid<span class="heti-spacing"> </span></span>中的单位元素和二元运算符，使之成为了一个幺半群：</p>
<pre><code class="language-haskell">class Arrow arr =&gt; ArrowZero arr where
    zeroArrow :: b `arr` c

class ArrowZero arr =&gt; ArrowPlus arr where
    (&lt;+&gt;) :: (b `arr` c) -&gt; (b `arr` c) -&gt; (b `arr` c)
</code></pre>
<hr/>
<h2 id="typeclasses_1">一些其它<span><span class="heti-spacing"> </span>Typeclasses</span><a class="headerlink" href="#typeclasses_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h2>
<h3 id="foldable">Foldable<a class="headerlink" href="#foldable" title="Permanent link">#</a></h3>
<p><span>Foldable<span class="heti-spacing"> </span></span>是表示可以折叠（fold）的类型类，在 <code>Data.Foldable</code> 中定义，这使得和<span class="heti-skip"><span class="heti-spacing"> </span>fold<span class="heti-spacing"> </span></span>相关的函数可以用在任意<span class="heti-skip"><span class="heti-spacing"> </span>Foldable<span class="heti-spacing"> </span></span>的实例类型上。它的定义是：</p>
<pre><code class="language-haskell">class Foldable t where
    fold     :: Monoid m =&gt; t m -&gt; m
    foldMap  :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m
    foldMap' :: Monoid m =&gt; (a -&gt; m) -&gt; t a -&gt; m
    foldr    :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldr'   :: (a -&gt; b -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldl    :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldl'   :: (b -&gt; a -&gt; b) -&gt; b -&gt; t a -&gt; b
    foldr1   :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a
    foldl1   :: (a -&gt; a -&gt; a) -&gt; t a -&gt; a
    toList   :: t a -&gt; [a]
    null     :: t a -&gt; Bool
    length   :: t a -&gt; Int
    elem     :: Eq a =&gt; a -&gt; t a -&gt; Bool
    maximum  :: Ord a =&gt; t a -&gt; a
    minimum  :: Ord a =&gt; t a -&gt; a
    sum      :: Num a =&gt; t a -&gt; a
    product  :: Num a =&gt; t a -&gt; a
    {-# MINIMAL foldMap | foldr #-}
</code></pre>
<p>最少只要实现 <code>foldr</code> 和 <code>foldMap</code> 其中之一就可以使一个类型成为<span class="heti-skip"><span class="heti-spacing"> </span>Foldable<span class="heti-spacing"> </span></span>的实例，其它的函数都有由这两个函数提供的默认实现，而且这两个函数之间也有相互实现。因此只要实现<span class="heti-skip"><span class="heti-spacing"> </span>foldr<span class="heti-spacing"> </span></span>或<span class="heti-skip"><span class="heti-spacing"> </span>foldMap<span class="heti-spacing"> </span></span>一个函数就可以使用所有其它<span class="heti-skip"><span class="heti-spacing"> </span>Foldable<span class="heti-spacing"> </span></span>中的函数。<span>foldr<span class="heti-spacing"> </span></span>函数在前面已经有学过，<span>foldMap<span class="heti-spacing"> </span></span>的例子是：</p>
<pre><code class="language-haskell">ghci&gt; foldMap Sum [1, 3, 5]
Sum {getSum = 9}
ghci&gt; foldMap Product [1, 3, 5]
Product {getProduct = 15}
ghci&gt; foldMap (replicate 3) [1, 2, 3]
[1,1,1,2,2,2,3,3,3]
</code></pre>
<h4 id="foldable_1"><span>Foldable<span class="heti-spacing"> </span></span>实例<a class="headerlink" href="#foldable_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p>[]、Maybe、Either a、<span>(,) a<span class="heti-spacing"> </span></span>都是<span class="heti-skip"><span class="heti-spacing"> </span>Foldable<span class="heti-spacing"> </span></span>的实例，标准容器库中的<span><span class="heti-spacing"> </span>Map</span>、<span>Set<span class="heti-spacing"> </span></span>等也都是<span class="heti-skip"><span class="heti-spacing"> </span>Foldable<span class="heti-spacing"> </span></span>的实例。也可以自定义二叉树类型，并使其成为<span class="heti-skip"><span class="heti-spacing"> </span>Foldable<span class="heti-spacing"> </span></span>的实例：</p>
<pre><code class="language-haskell">data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)

instance Foldable Tree where 
    foldMap :: Monoid m =&gt; (a -&gt; m) -&gt; Tree a -&gt; m
    foldMap f Empty        = mempty
    foldMap f (Leaf x)     = f x
    foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
</code></pre>
<h4 id="_25">常用函数<a class="headerlink" href="#_25" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<ul>
<li><code>asum</code> :: (Alternative f, Foldable t) =&gt; t (f a) -&gt; f a，用<span class="heti-skip"><span class="heti-spacing"> </span>&lt;|&gt;<span class="heti-spacing"> </span></span>逐个连接所有元素</li>
<li><code>sequenceA_</code> :: (Applicative f, Foldable t) =&gt; t (f a) -&gt; f ()，由于丢弃结果，所以<span class="heti-skip"><span class="heti-spacing"> </span>Foldable t<span class="heti-spacing"> </span></span>就可以满足；因此不同于<span class="heti-skip"><span class="heti-spacing"> </span>sequenceA<span class="heti-spacing"> </span></span>需要<span><span class="heti-spacing"> </span>Traversable</span></li>
<li><code>traverse_</code> :: (Applicative f, Foldable t) =&gt; (a -&gt; f b) -&gt; t a -&gt; f ()</li>
<li><code>for_</code> :: (Applicative f, Foldable t) =&gt; t a -&gt; (a -&gt; f b) -&gt; f ()</li>
</ul>
<h3 id="traversable">Traversable<a class="headerlink" href="#traversable" title="Permanent link">#</a></h3>
<p><span>Traversable<span class="heti-spacing"> </span></span>是表示可遍历的类型类，在 <code>Data.Traversable</code> 模块中定义，它是<span class="heti-skip"><span class="heti-spacing"> </span>Foldable<span class="heti-spacing"> </span></span>的升级版，同时也是一个<span><span class="heti-spacing"> </span>Functor</span>，它的定义是：</p>
<pre><code class="language-haskell">class (Functor t, Foldable t) =&gt; Traversable t where 
    traverse  :: Applicative f =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)
    sequenceA :: Applicative f =&gt; t (f a) -&gt; f (t a)
    mapM      ::       Monad m =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
    sequence  ::       Monad m =&gt; t (m a) -&gt; m (t a)
    {-# MINIMAL traverse | sequenceA #-}
</code></pre>
<p>最少只需要实现<span class="heti-skip"><span class="heti-spacing"> </span>traverse<span class="heti-spacing"> </span></span>函数或者<span class="heti-skip"><span class="heti-spacing"> </span>sequenceA<span class="heti-spacing"> </span></span>函数。其中各个函数的功能通过类型签名也都能推测出来。但是其中<span class="heti-skip"><span class="heti-spacing"> </span>mapM<span class="heti-spacing"> </span></span>就是<span><span class="heti-spacing"> </span>traverse</span>，<span>sequence<span class="heti-spacing"> </span></span>就是<span><span class="heti-spacing"> </span>sequenceA</span>，它们存在只是历史遗留</p>
<h4 id="traversable_1"><span>Traversable<span class="heti-spacing"> </span></span>实例<a class="headerlink" href="#traversable_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<pre><code class="language-haskell">instance Traversable Maybe where
    traverse _ Nothing = pure Nothing
    traverse f (Just x) = Just &lt;$&gt; f x

instance Traversable [] where
    {-# INLINE traverse #-}
    traverse f = foldr cons_f (pure [])
      where cons_f x ys = liftA2 (:) (f x) ys

instance Traversable (Either a) where
    traverse _ (Left x) = pure (Left x)
    traverse f (Right y) = Right &lt;$&gt; f y

instance Traversable ((,) a) where
    traverse f (x, y) = (,) x &lt;$&gt; f y

...
</code></pre>
<p>上面的<span class="heti-skip"><span class="heti-spacing"> </span>Tree<span class="heti-spacing"> </span></span>也可以成为<span class="heti-skip"><span class="heti-spacing"> </span>Traversable<span class="heti-spacing"> </span></span>的实例：</p>
<pre><code class="language-haskell">instance Functor Tree where
    fmap :: (a -&gt; b) -&gt; Tree a -&gt; Tree b
    fmap     g Empty        = Empty
    fmap     g (Leaf x)     = Leaf $ g x
    fmap     g (Node l x r) = Node (fmap g l)
                                   (g x)
                                   (fmap g r)

instance Traversable Tree where
    traverse :: Applicative f =&gt; (a -&gt; f b) -&gt; Tree a -&gt; f (Tree b) 
    traverse g Empty        = pure Empty
    traverse g (Leaf x)     = Leaf &lt;$&gt; g x
    traverse g (Node l x r) = Node &lt;$&gt; traverse g l
                                   &lt;*&gt; g x
                                   &lt;*&gt; traverse g r
</code></pre>
<h4 id="traversable_laws">Traversable Laws<a class="headerlink" href="#traversable_laws" title="Permanent link">#</a></h4>
<p><span>Traversable<span class="heti-spacing"> </span></span>也有两条定律：
1. traverse Identity = Identity
2. traverse (Compose . fmap g . f) = Compose . fmap (traverse g) . traverse f </p>
<p>其中<span class="heti-skip"><span class="heti-spacing"> </span>Identity<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>Compose<span class="heti-spacing"> </span></span>分别定义在 <code>Data.Functor.Identity</code> 和 <code>Data.Functor.Compose</code> 两个模块中：</p>
<pre><code class="language-haskell">newtype Identity a = Identity { runIdentity :: a } deriving (...)
newtype Compose f g a = Compose { getCompose :: f (g a) } deriving (...)
</code></pre>
<h3 id="bifunctor">Bifunctor<a class="headerlink" href="#bifunctor" title="Permanent link">#</a></h3>
<p><span>Functor<span class="heti-spacing"> </span></span>的实例的<span class="heti-skip"><span class="heti-spacing"> </span>kind<span class="heti-spacing"> </span></span>都是<span><span class="heti-spacing"> </span>* -&gt; *</span>，因此<span class="heti-skip"><span class="heti-spacing"> </span>fmap<span class="heti-spacing"> </span></span>只能将一个函数映射到一个值上。而<span><span class="heti-spacing"> </span>Bifunctor</span>（在 <code>Data.Bifunctor</code> 模块中定义）的实例的<span class="heti-skip"><span class="heti-spacing"> </span>kind<span class="heti-spacing"> </span></span>是<span><span class="heti-spacing"> </span>* -&gt; * -&gt; *</span>，而且它的<span class="heti-skip"><span class="heti-spacing"> </span>bimap<span class="heti-spacing"> </span></span>可以同时将两个函数映射到两个值上：</p>
<pre><code class="language-haskell">class Bifunctor p where 
    bimap  :: (a -&gt; b) -&gt; (c -&gt; d) -&gt; p a c -&gt; p b d 
    first  :: (a -&gt; b) -&gt; p a c -&gt; p b c 
    second :: (b -&gt; c) -&gt; p a b -&gt; p a c 
    {-# MINIMAL bimap | first, second #-}
</code></pre>
<p>同时<span class="heti-skip"><span class="heti-spacing"> </span>bimap<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>first,second<span class="heti-spacing"> </span></span>之间也可以相互转换：</p>
<pre><code class="language-haskell">bimap f g = first f . second g

first  f = bimap f id
second g = bimap id g
</code></pre>
<p>对于<span><span class="heti-spacing"> </span>Functor</span>，<span>((,) e)<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>Either e<span class="heti-spacing"> </span></span>才是<span class="heti-skip"><span class="heti-spacing"> </span>Functor<span class="heti-spacing"> </span></span>的实例，因为他们是<span><span class="heti-spacing"> </span>* -&gt; *</span>。但是对于<span><span class="heti-spacing"> </span>Bifunctor</span>，<span>(,)<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>Either<span class="heti-spacing"> </span></span>就是<span class="heti-skip"><span class="heti-spacing"> </span>Bifunctor<span class="heti-spacing"> </span></span>的实例：</p>
<pre><code class="language-haskell">ghci&gt; bimap (+1) length (4, [1,2,3])
(5,3)
</code></pre>
<h4 id="bifunctor_laws">Bifunctor Laws<a class="headerlink" href="#bifunctor_laws" title="Permanent link">#</a></h4>
<ol>
<li>bimap id id = id
    first id = id
    second id = id</li>
<li>bimap (f . g) (h . i) = bimap f h . bimap g i
    first  (f . g) = first f  . first g
    second (f . g) = second f . second g</li>
</ol>
<h3 id="category">Category<a class="headerlink" href="#category" title="Permanent link">#</a></h3>
<p><span>Haskell<span class="heti-spacing"> </span></span>中的<span class="heti-skip"><span class="heti-spacing"> </span>Category<span class="heti-spacing"> </span></span>将一般的函数推广到了普遍的态射上，它在 <code>Control.Category</code> 模块中，定义是：</p>
<pre><code class="language-haskell">class Category cat where 
    id  :: cat a a 
    (.) :: cat b c -&gt; cat a b -&gt; cat a c
</code></pre>
<p>它的实例有 <code>(-&gt;)</code> 和 <code>Kleisli m</code>：</p>
<pre><code class="language-haskell">instance Category (-&gt;) where
    id = GHC.Base.id
    (.) = (GHC.Base..)
</code></pre>
<p><span>Kleisli<span class="heti-spacing"> </span></span>是一个范畴，用来表示函数<span><span class="heti-spacing"> </span>a -&gt; m b</span>，<span>Haskell<span class="heti-spacing"> </span></span>中，它在 <code>Control.Arrow</code> 模块中定义：</p>
<pre><code class="language-haskell">newtype Kleisli m a b = Kleisli { runKleisli :: a -&gt; m b }

instance Monad m =&gt; Category (Kleisli m) where
    id :: Kleisli m a a
    id = Kleisli return

    (.) :: Kleisli m b c -&gt; Kleisli m a b -&gt; Kleisli m a c
    Kleisli g . Kleisli h = Kleisli (h &gt;=&gt; g)
</code></pre>
<p><span>Category<span class="heti-spacing"> </span></span>要满足的定律只有<span class="heti-skip"><span class="heti-spacing"> </span>id<span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span>(.)<span class="heti-spacing"> </span></span>操作的单位元，以及<span class="heti-skip"><span class="heti-spacing"> </span>(.)<span class="heti-spacing"> </span></span>操作是可结合的</p>
<p>同时<span class="heti-skip"><span class="heti-spacing"> </span>Category<span class="heti-spacing"> </span></span>还提供了两个函数 <code>&lt;&lt;&lt;</code> 和 <code>&gt;&gt;&gt;</code>：</p>
<pre><code class="language-haskell">(&lt;&lt;&lt;) :: Category cat =&gt; cat b c -&gt; cat a b -&gt; cat a c
(&lt;&lt;&lt;) = (.)

(&gt;&gt;&gt;) :: Category cat =&gt; cat a b -&gt; cat b c -&gt; cat a c 
f &gt;&gt;&gt; g = g . f 
</code></pre>
<h3 id="arrow">Arrow<a class="headerlink" href="#arrow" title="Permanent link">#</a></h3>
<p><span>Arrow<span class="heti-spacing"> </span></span>将函数进一步抽象化，它定义在 <code>Control.Arrow</code> 模块中：</p>
<pre><code class="language-haskell">class Category a =&gt; Arrow a where 
    arr    :: (b -&gt; c) -&gt; a b c 
    first  :: a b c -&gt; a (b, d) (c, d)
    second :: a b c -&gt; a (d, b) (d, c)
    (***)  :: a b c -&gt; a b' c' -&gt; a (b, b') (c, c')
    (&amp;&amp;&amp;)  :: a b c -&gt; a b c' -&gt; a b (c, c')
    {-# MINIMAL arr, (first | (***)) #-}
</code></pre>
<p>其中：</p>
<ul>
<li><code>arr</code> 函数将一个函数变成一个<span><span class="heti-spacing"> </span>Arrow</span></li>
<li><code>first</code> 函数将一个<span class="heti-skip"><span class="heti-spacing"> </span>Arrow<span class="heti-spacing"> </span></span>变成一个二元组间的<span><span class="heti-spacing"> </span>Arrow</span>，且只会对一个元素进行操作，第二个元素保持不变</li>
<li><code>second</code> 函数与<span class="heti-skip"><span class="heti-spacing"> </span>first<span class="heti-spacing"> </span></span>相反，第一个元素保持不变</li>
<li><code>***</code> 函数是<span class="heti-skip"><span class="heti-spacing"> </span>Arrow<span class="heti-spacing"> </span></span>之间的<span><span class="heti-spacing"> </span>parallel composition</span>，对于函数<span><span class="heti-spacing"> </span>: (g *** h) (x, y) = (g x, h y)</span></li>
<li><code>&amp;&amp;&amp;</code> 函数是<span class="heti-skip"><span class="heti-spacing"> </span>Arrow<span class="heti-spacing"> </span></span>之间的<span><span class="heti-spacing"> </span>fanout composition</span>，对于函数<span><span class="heti-spacing"> </span>: (g &amp;&amp;&amp; h) x = (g x, h x)</span></li>
</ul>
<p>它的实例也有<span class="heti-skip"><span class="heti-spacing"> </span>(-&gt;)<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>Kleisli</span>：</p>
<pre><code class="language-haskell">instance Arrow (-&gt;) where
  arr :: (b -&gt; c) -&gt; (b -&gt; c)
  arr g = g

  first :: (b -&gt; c) -&gt; ((b,d) -&gt; (c,d))
  first g (x,y) = (g x, y)

instance Monad m =&gt; Arrow (Kleisli m) where
  arr :: (b -&gt; c) -&gt; Kleisli m b c
  arr f = Kleisli (return . f)

  first :: Kleisli m b c -&gt; Kleisli m (b,d) (c,d)
  first (Kleisli f) = Kleisli (\ ~(b,d) -&gt; do c &lt;- f b
                                              return (c,d) )
</code></pre>
<p>常用函数：</p>
<pre><code class="language-haskell">returnA :: Arrow a =&gt; a b b
returnA = arr id

(^&gt;&gt;) :: Arrow a =&gt; (b -&gt; c) -&gt; a c d -&gt; a b d
f ^&gt;&gt; a = arr f &gt;&gt;&gt; a

(&gt;&gt;^) :: Arrow a =&gt; a b c -&gt; (c -&gt; d) -&gt; a b d
a &gt;&gt;^ f = a &gt;&gt;&gt; arr f

(&lt;&lt;^) :: Arrow a =&gt; a c d -&gt; (b -&gt; c) -&gt; a b d
a &lt;&lt;^ f = a &lt;&lt;&lt; arr f

(^&lt;&lt;) :: Arrow a =&gt; (c -&gt; d) -&gt; a b c -&gt; a b d
f ^&lt;&lt; a = arr f &lt;&lt;&lt; a
</code></pre>
<h4 id="arrow_notation">Arrow notation<a class="headerlink" href="#arrow_notation" title="Permanent link">#</a></h4>
<p>类似<span><span class="heti-spacing"> </span>do-notation</span>，<span>Arrow<span class="heti-spacing"> </span></span>也提供了一套方便的语句：</p>
<pre><code class="language-haskell">proc x -&gt; do 
    y &lt;- action1 -&lt; ... 
    z &lt;- action2 -&lt; ...
    returnA -&lt; ...
</code></pre>
<p>其中<span class="heti-skip"><span class="heti-spacing"> </span>proc<span class="heti-spacing"> </span></span>代替了<span class="heti-skip"><span class="heti-spacing"> </span>lambda<span class="heti-spacing"> </span></span>表达式中的斜杠<span><span class="heti-spacing"> </span>\</span>，<span>-&lt;<span class="heti-spacing"> </span></span>右边的为输入，左边的为接收输入的函数。比如，下面三种写法达成的效果是一样的：</p>
<pre><code class="language-haskell">f :: Int -&gt; (Int, Int)
f = \x -&gt;
    let y  = 2 * x
        z1 = y + 3
        z2 = y - 5
    in (z1, z2) 
-- ghci&gt; f 10 
-- (23,15)

fM :: Int -&gt; Identity (Int, Int)
fM = \x -&gt; do
    y  &lt;- return (2 * x)
    z1 &lt;- return (y + 3)
    z2 &lt;- return (y - 5)
    return (z1, z2)

-- ghci&gt; runIdentity (fM 10)
-- (23,15)

fA :: Int -&gt; (Int, Int)
fA = proc x -&gt; do
    y  &lt;- (2 *) -&lt; x
    z1 &lt;- (+ 3) -&lt; y
    z2 &lt;- (subtract 5) -&lt; y
    returnA -&lt; (z1, z2)

-- ghci&gt; fA 10
-- (23,15)
</code></pre>
<h4 id="arrowchoice">ArrowChoice<a class="headerlink" href="#arrowchoice" title="Permanent link">#</a></h4>
<pre><code class="language-haskell">class Arrow a =&gt; ArrowChoice a where
    left :: a b c -&gt; a (Either b d) (Either c d)
    left = (+++ id)

    right :: a b c -&gt; a (Either d b) (Either d c)
    right = (id +++)

    (+++) :: a b c -&gt; a b' c' -&gt; a (Either b b') (Either c c')
    f +++ g = left f &gt;&gt;&gt; arr mirror &gt;&gt;&gt; left g &gt;&gt;&gt; arr mirror
      where
        mirror :: Either x y -&gt; Either y x
        mirror (Left x) = Right x
        mirror (Right y) = Left y

    (|||) :: a b d -&gt; a c d -&gt; a (Either b c) d
    f ||| g = f +++ g &gt;&gt;&gt; arr untag
      where
        untag (Left x) = x
        untag (Right y) = y

instance ArrowChoice (-&gt;) where
    left f = f +++ id
    right f = id +++ f
    f +++ g = (Left . f) ||| (Right . g)
    (|||) = either

instance Monad m =&gt; ArrowChoice (Kleisli m) where
    left f = f +++ arr id
    right f = arr id +++ f
    f +++ g = (f &gt;&gt;&gt; arr Left) ||| (g &gt;&gt;&gt; arr Right)
    Kleisli f ||| Kleisli g = Kleisli (either f g)
</code></pre>
<h4 id="arrowzero_arrowplus">ArrowZero &amp; ArrowPlus<a class="headerlink" href="#arrowzero_arrowplus" title="Permanent link">#</a></h4>
<pre><code class="language-haskell">class Arrow a =&gt; ArrowZero a where
    zeroArrow :: a b c

class ArrowZero a =&gt; ArrowPlus a where
    (&lt;+&gt;) :: a b c -&gt; a b c -&gt; a b c

instance MonadPlus m =&gt; ArrowZero (Kleisli m) where
    zeroArrow = Kleisli (\_ -&gt; mzero)

instance MonadPlus m =&gt; ArrowPlus (Kleisli m) where
    Kleisli f &lt;+&gt; Kleisli g = Kleisli (\x -&gt; f x `mplus` g x)
</code></pre>
<h4 id="_26">例子<a class="headerlink" href="#_26" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<pre><code class="language-haskell">ghci&gt; runKleisli ((Kleisli (\x -&gt; [x * 2])) &lt;+&gt; (Kleisli (\x -&gt; [x, -x]))) 2
[4,2,-2]
ghci&gt; either (+2) (*3) (Left 3)
5
ghci&gt; either (+2) (*3) (Right 3)
9
ghci&gt; (+2) ||| (*3) $ (Left 3)
5
ghci&gt; (+2) +++ (*3) $ (Left 3)
Left 5
ghci&gt; (+2) ||| (*3) $ (Right 3)
9
ghci&gt; (+2) +++ (*3) $ (Right 3)
Right 9
ghci&gt; left (+2) (Left 3)
Left 5
ghci&gt; right (*3) (Right 3)
Right 9
ghci&gt; left (+2) (Right 3)
Right 3
ghci&gt; right (*3) (Left 3)
Left 3
ghci&gt; runKleisli ((Kleisli (\x -&gt; [x * 2])) ||| (Kleisli (\x -&gt; [x, -x]))) (Left 3)
[6]
ghci&gt; runKleisli ((Kleisli (\x -&gt; [x * 2])) ||| (Kleisli (\x -&gt; [x, -x]))) (Right 3)
[3,-3]
ghci&gt; runKleisli ((Kleisli (\x -&gt; [x * 2])) +++ (Kleisli (\x -&gt; [x, -x]))) (Left 3)
[Left 6]
ghci&gt; runKleisli ((Kleisli (\x -&gt; [x * 2])) +++ (Kleisli (\x -&gt; [x, -x]))) (Right 3)
[Right 3,Right (-3)]
</code></pre>
<hr/>
<h2 id="haskell_1"><span>Haskell<span class="heti-spacing"> </span></span>与范畴论<a class="headerlink" href="#haskell_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h2>
<p><span>Haskell<span class="heti-spacing"> </span></span>中的函子单子等都与范畴论（category theory）有很多联系，所以打算简单了解一下范畴论的相关内容。</p>
<blockquote>
<p><strong>范畴论</strong>是数学的一门学科，以抽象的方法处理数学概念，将这些概念形式化成一组组的“物件”及“态射”。数学中许多重要的领域可以形式化为范畴。使用范畴论可以令这些领域中许多难理解、难捉摸的数学结论更容易叙述证明。
</p><div style="text-align: right">———— 维基百科</div>
</blockquote>
<h3 id="category_1">范畴（Category）<a class="headerlink" href="#category_1" title="Permanent link">#</a></h3>
<p>范畴本质上是一个简单的集合，一个范畴<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{C}$<span class="heti-spacing"> </span></span>包含三个组成成分：</p>
<ul>
<li>一个类<span><span class="heti-spacing"> </span>$\mathrm{ob}(\mathbf{C})$</span>：其中元素称为<strong>对象（objects）</strong></li>
<li>一个类<span><span class="heti-spacing"> </span>$\mathrm{hom}(\mathbf{C})$</span>：其中元素称为<strong>态射（morphisms）</strong>（或<strong>箭号（arrows）</strong><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：每个态射连接了两个对象：源对象（source object<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>、目标对象（target object<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。如果<span class="heti-skip"><span class="heti-spacing"> </span>$f$<span class="heti-spacing"> </span></span>是从源对象<span class="heti-skip"><span class="heti-spacing"> </span>$A$<span class="heti-spacing"> </span></span>到目标对象<span><span class="heti-spacing"> </span>$B$</span>（$A, B\in \mathrm{ob}(\mathbf{C})$）的态射，那么记为<span><span class="heti-spacing"> </span>$f : A\to B$</span></li>
<li>一个二元运算，称为态射<strong>复合（composition）</strong>：两个态射<span><span class="heti-spacing"> </span>$g : A\to B$</span>、<span>$f : B\to C$<span class="heti-spacing"> </span></span>的复合记为<span><span class="heti-spacing"> </span>$f\circ g : A\to C$</span><br/>
  在 Haskell 和大部分数学理论中都是从右向左计算，即 $f\circ g$ 中是先计算 $g : A\to B$ 再计算 $f : B\to C$</li>
</ul>
<p>许多东西都可以组成范畴。比如<span><span class="heti-spacing"> </span>:</span></p>
<details class="example" open="open">
<summary>例</summary>
<p> <span>$\mathbf{Set}$<span class="heti-spacing"> </span></span>是一个范畴，对象为所有集合，态射为集合之间的函数，复合即函数之间的复合</p>
<p> <span>$\mathbf{Grp}$<span class="heti-spacing"> </span></span>是一个范畴，对象为所有群，态射为群同态（group homomorphisms<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，例如对于群<span><span class="heti-spacing"> </span>$(G,</span><em><span>)$<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>$(H,\cdot )$</span>，有群同态<span><span class="heti-spacing"> </span>$h : (G,</span></em>)\to  (H,\cdot )$，则需要对于<span class="heti-skip"><span class="heti-spacing"> </span>$G$<span class="heti-spacing"> </span></span>中的任意元素<span class="heti-skip"><span class="heti-spacing"> </span>$u,v$<span class="heti-spacing"> </span></span>满足</p>
<p>$$h(u*v)=h(u)\cdot h(v)$$</p>
</details>
<div class="admonition warning">
<p class="admonition-title"><strong>注意</strong></p>
<p>态射不必须为函数；而且可以存在源对象和目标对象都相同的不同态射</p>
</div>
<h4 id="_27">范畴公理<a class="headerlink" href="#_27" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p>每个范畴都需要满足三条定律：</p>
<ol>
<li>态射复合需要满足<strong>结合律（associativity）</strong>：$f\circ (g\circ h) = (f\circ g)\circ h$</li>
<li>范畴在复合操作下是<strong>闭合的（closed）</strong>：<br/>
     如果范畴 $\mathbf{C}$ 中存在态射 $f : B\to C$、$g : A\to B$，那么范畴 $\mathbf{C}$ 中也一定存在态射 $h : A\to C$，且 $h=f\circ g$</li>
<li>每个对象都需要有<strong>单位态射（identity morphisms）</strong>：<br/>
     对于范畴$\mathbf{C}$中的对象$A$，一定存在单位态射$\mathrm{id}_A : A\to A$，且对于每个态射$g : A\to B$，一定有： $g\circ\mathrm{id}_A = \mathrm{id}_B\circ g = g$</li>
</ol>
<h4 id="mathbfhask"><span>$\mathbf{Hask}$<span class="heti-spacing"> </span></span>范畴<a class="headerlink" href="#mathbfhask" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p>范畴<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{Hask}$<span class="heti-spacing"> </span></span>的对象为<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>中的类型（types<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，态射是<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>中的函数，复合运算是 <code>(.)</code>。即从类型<span class="heti-skip"><span class="heti-spacing"> </span>A<span class="heti-spacing"> </span></span>到类型<span class="heti-skip"><span class="heti-spacing"> </span>B<span class="heti-spacing"> </span></span>的函数<span class="heti-skip"><span class="heti-spacing"> </span>f :: A -&gt; B<span class="heti-spacing"> </span></span>就是<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{Hask}$<span class="heti-spacing"> </span></span>范畴中的一个态射。而函数<span><span class="heti-spacing"> </span>f :: B -&gt; C</span> 、<span>g :: A -&gt; B<span class="heti-spacing"> </span></span>的组合<span class="heti-skip"><span class="heti-spacing"> </span>f . g<span class="heti-spacing"> </span></span>就是一个新的函数<span><span class="heti-spacing"> </span>h :: A -&gt; C</span>。</p>
<p>对于三条定律：</p>
<ol>
<li>第一条显然满足：f . (g . h) = (f . g) . h</li>
<li>第二条也显然满足，如果有函数<span><span class="heti-spacing"> </span>f :: B -&gt; C</span> 、g :: A -&gt; B，一定有函数<span><span class="heti-spacing"> </span>h = (f . g) :: A -&gt; C</span> </li>
<li>对于第三条定律，<span>Haskell<span class="heti-spacing"> </span></span>中存在单位函数<span><span class="heti-spacing"> </span>id</span> ，但<span class="heti-skip"><span class="heti-spacing"> </span>id<span class="heti-spacing"> </span></span>是多态（polymorphic）的，要为其指定类型使其变成单态（monomorphic）的。比如态射<span class="heti-skip"><span class="heti-spacing"> </span>$\mathrm{id}_A$<span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>中就可以表示为<span><span class="heti-spacing"> </span>id :: A -&gt; A</span>。并且显然满足第三条定律（其中<span><span class="heti-spacing"> </span>f :: A -&gt; B</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：
<br/>
<p style="text-align: center;">(id :: B -&gt; B) . f = f . (id :: A -&gt; A) = f</p>
</li>
</ol>
<h3 id="functors_1">函子（Functors）<a class="headerlink" href="#functors_1" title="Permanent link">#</a></h3>
<p>一个范畴中的态射将两个对象联系起来，而函子则会将两个范畴联系起来。换句话说，函子就是从一个范畴到另一个范畴的变换。比如对于范畴<span><span class="heti-spacing"> </span>$\mathbf{C}$</span>、$\mathbf{D}$，定义函子<span class="heti-skip"><span class="heti-spacing"> </span>$F : \mathbf{C}\to\mathbf{D}$<span class="heti-spacing"> </span></span>满足：</p>
<ul>
<li>对于<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{C}$<span class="heti-spacing"> </span></span>中的任意对象<span><span class="heti-spacing"> </span>$A$</span>，在<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{D}$<span class="heti-spacing"> </span></span>中都有对象<span><span class="heti-spacing"> </span>$F(A)$</span></li>
<li>对于<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{C}$<span class="heti-spacing"> </span></span>中的任意态射<span><span class="heti-spacing"> </span>$f : A\to B$</span>，在<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{D}$<span class="heti-spacing"> </span></span>中都有态射<span><span class="heti-spacing"> </span>$F(f) : F(A)\to F(B)$</span></li>
</ul>
<details class="example" open="open">
<summary>例</summary>
<p>遗忘函子（forgetful functor）$U : \mathbf{Grp}\to\mathbf{Set}$，将一个群映射到一个集合中，将群同态映射到集合间的函数</p>
<p>幂集函子（power set functor）$P : \mathbf{Set}\to\mathbf{Set}$，将一个集合映射到它的幂集，将原集合中的函数<span class="heti-skip"><span class="heti-spacing"> </span>$f : A\to B$<span class="heti-spacing"> </span></span>映射到函数<span><span class="heti-spacing"> </span>$P(f) : \mathcal{P}(A)\to\mathcal{P}(B)$</span>，即从<span class="heti-skip"><span class="heti-spacing"> </span>$U\subseteq A$<span class="heti-spacing"> </span></span>到值域<span class="heti-skip"><span class="heti-spacing"> </span>$f(U)\subseteq B$<span class="heti-spacing"> </span></span>的映射</p>
<p>自函子（endofunctor）$1_{\mathbf{C}} : \mathbf{C}\to\mathbf{C}$，将一个范畴映射到它本身</p>
</details>
<h4 id="_28">函子公理<a class="headerlink" href="#_28" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p>函子<span class="heti-skip"><span class="heti-spacing"> </span>$F : \mathbf{C}\to\mathbf{D}$<span class="heti-spacing"> </span></span>也需要满足两个公理：</p>
<ol>
<li>对于任意对象<span><span class="heti-spacing"> </span>$X\in\mathbf{C}$</span>，恒有<span><span class="heti-spacing"> </span>$F(\mathrm{id}</span><em f_x_="F(X)">X)=\mathrm{id}</em>$</li>
<li>对于态射<span><span class="heti-spacing"> </span>$f : Y\to Z$</span>、$g : X\to Y$，恒有<span><span class="heti-spacing"> </span>$F(f\circ g) = F(f)\circ F(g)$</span></li>
</ol>
<h4 id="mathbfhask_1"><span>$\mathbf{Hask}$<span class="heti-spacing"> </span></span>范畴上的函子<a class="headerlink" href="#mathbfhask_1" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p><span>Haskell<span class="heti-spacing"> </span></span>中的<span class="heti-skip"><span class="heti-spacing"> </span>Functor<span class="heti-spacing"> </span></span>定义是：</p>
<pre><code class="language-haskell">class Functor (f :: * -&gt; *) where 
    fmap :: (a -&gt; b) -&gt; f a -&gt; f b
</code></pre>
<p>对于<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>中的<span><span class="heti-spacing"> </span>Functor</span>，它实际上是从<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{Hask}$<span class="heti-spacing"> </span></span>范畴（types）到它子范畴的变换。比如列表函子<span><span class="heti-spacing"> </span>$\texttt{[]} : \mathbf{Hask}\to\mathbf{Lst}$</span>（其中<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{Lst}$<span class="heti-spacing"> </span></span>是所有<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>中列表类型构成的范畴）</p>
<p>它也达成了范畴论中对于函子的要求。函子需要进行两个操作：将一个范畴中的对象映射到另一个范畴中、将一个范畴中的态射映射到另一个范畴中。以<span class="heti-skip"><span class="heti-spacing"> </span>Maybe<span class="heti-spacing"> </span></span>为例，它实现了函子的要求：</p>
<ol>
<li><span>Maybe<span class="heti-spacing"> </span></span>是一个类型构造器，他可以将任意类型<span class="heti-skip"><span class="heti-spacing"> </span>T<span class="heti-spacing"> </span></span>变成新类型<span><span class="heti-spacing"> </span>Maybe T</span>，相当于从<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{Hask}$<span class="heti-spacing"> </span></span>范畴的对象变成了<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{Maybe}$<span class="heti-spacing"> </span></span>范畴的对象 </li>
<li><span>fmap<span class="heti-spacing"> </span></span>函数接收一个<span class="heti-skip"><span class="heti-spacing"> </span>a -&gt; b<span class="heti-spacing"> </span></span>类型的函数，返回一个<span class="heti-skip"><span class="heti-spacing"> </span>Maybe a -&gt; Maybe b<span class="heti-spacing"> </span></span>类型的函数，相当于将<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{Hask}$<span class="heti-spacing"> </span></span>范畴中的态射<span class="heti-skip"><span class="heti-spacing"> </span>$f : A\to B$<span class="heti-spacing"> </span></span>映射成了<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{Maybe}$<span class="heti-spacing"> </span></span>范畴中的态射<span><span class="heti-spacing"> </span>$\mathbf{Maybe}(f) : \mathbf{Maybe}(A)\to\mathbf{Maybe}(B)$</span></li>
</ol>
<div class="admonition warning">
<p class="admonition-title">注意</p>
<p>时刻记住这里研究的是<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{Hask}$<span class="heti-spacing"> </span></span>范畴和它的子范畴，对象是类型而不是值，态射是函数也指的是从类型到类型</p>
</div>
<p>同时，<span>Haskell<span class="heti-spacing"> </span></span>中的<span class="heti-skip"><span class="heti-spacing"> </span>Functor<span class="heti-spacing"> </span></span>也满足函子公理：</p>
<ol>
<li><span>fmap id = id<span class="heti-spacing"> </span></span>即<span><span class="heti-spacing"> </span>fmap (id :: A -&gt; A) = (id :: f A -&gt; f A)</span></li>
<li>fmap (f . g) = fmap f . fmap g</li>
</ol>
<h3 id="monads">单子（Monads）<a class="headerlink" href="#monads" title="Permanent link">#</a></h3>
<blockquote>
<p>一个单子说白了不过就是自函子范畴上的一个幺半群而已<span><span class="heti-spacing"> </span>_(:</span>з」∠)_</p>
</blockquote>
<p>自函子在前面说到过是从一个范畴到自身的一个函子，如范畴<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{C}$<span class="heti-spacing"> </span></span>上的自函子是<span><span class="heti-spacing"> </span>$F : \mathbf{C}\to\mathbf{C}$</span>。自函子范畴就是对象都是自函子的范畴。幺半群和<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>中学到的<span class="heti-skip"><span class="heti-spacing"> </span>Monoid<span class="heti-spacing"> </span></span>类型类一样，是一个有可结合二元运算和单位元的代数结构。因此单子就是一个自函子，而且它有可结合二元运算（<span>Haskell<span class="heti-spacing"> </span></span>中 <code>&gt;=&gt;</code>）和单位元（<span>Haskell<span class="heti-spacing"> </span></span>中 <code>return</code><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<p>一个单子<span class="heti-skip"><span class="heti-spacing"> </span>$M : \mathbf{C}\to\mathbf{C}$<span class="heti-spacing"> </span></span>还包含两个态射（对于范畴<span class="heti-skip"><span class="heti-spacing"> </span>$\mathbf{C}$<span class="heti-spacing"> </span></span>中的所有对象<span><span class="heti-spacing"> </span>$X$</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<ol>
<li>$\mathrm{unit}_X^M : X\to M(X)$</li>
<li>$\mathrm{join}_X^M : M(M(X))\to M(X)$</li>
</ol>
<p>（当式子中的单子明显是<span class="heti-skip"><span class="heti-spacing"> </span>$M$<span class="heti-spacing"> </span></span>时，可以省略上标<span><span class="heti-spacing"> </span>${}^M$</span>）</p>
<p><span>Haskell<span class="heti-spacing"> </span></span>中<span class="heti-skip"><span class="heti-spacing"> </span>Monad<span class="heti-spacing"> </span></span>的定义是：</p>
<pre><code class="language-haskell">class Functor m =&gt; Monad m where 
    return :: a -&gt; m a 
    (&gt;&gt;=)  :: m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>
<p>其中很显然多态函数 <code>return</code> 对应了定义中的<span><span class="heti-spacing"> </span>$\mathrm{unit}$</span>，但是 <code>&gt;&gt;=</code> 和<span class="heti-skip"><span class="heti-spacing"> </span>$\mathrm{join}$<span class="heti-spacing"> </span></span>的对应关系并不明显。因此<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>中有一个工具函数 <code>join</code>，它的效果就是定义中的<span><span class="heti-spacing"> </span>$\mathrm{join}$</span>，而且它可以和 <code>&gt;&gt;=</code> 互相定义：</p>
<pre><code class="language-haskell">join :: Monad m =&gt; m (m a) -&gt; m a
join x = x &gt;&gt;= id

(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b 
x &gt;&gt;= f = join $ fmap f x
</code></pre>
<p>所以<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>中为<span class="heti-skip"><span class="heti-spacing"> </span>Monad<span class="heti-spacing"> </span></span>要求定义 <code>&gt;&gt;=</code> 就相当于定义了<span><span class="heti-spacing"> </span>$\mathrm{join}$</span></p>
<p>例如，幂集函子<span class="heti-skip"><span class="heti-spacing"> </span>$P : \mathbf{Set}\to\mathbf{Set}$<span class="heti-spacing"> </span></span>也是一个单子，可以为它定义<span class="heti-skip"><span class="heti-spacing"> </span>$\mathrm{unit}$<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>$\mathrm{join}$<span class="heti-spacing"> </span></span>两个态射。<span>Haskell<span class="heti-spacing"> </span></span>中的列表也可以近似看作幂集函子。</p>
<details class="abstract" open="open">
<summary>态射<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>函数的类型</summary>
<table>
<thead>
<tr>
<th style="text-align: center;">幂集函子</th>
<th style="text-align: center;"><span>Haskell<span class="heti-spacing"> </span></span>中列表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">一个集合<span class="heti-skip"><span class="heti-spacing"> </span>$S$<span class="heti-spacing"> </span></span>和一个态射<span><span class="heti-spacing"> </span>$f : A\to B$</span></td>
<td style="text-align: center;">一个类型<span class="heti-skip"><span class="heti-spacing"> </span>T<span class="heti-spacing"> </span></span>和一个函数<span><span class="heti-spacing"> </span>f :: A -&gt; B</span></td>
</tr>
<tr>
<td style="text-align: center;">$P(f) : \mathcal{P}(A)\to\mathcal{P}(B)$</td>
<td style="text-align: center;">fmap f :: [A] -&gt; [B]</td>
</tr>
<tr>
<td style="text-align: center;">$\mathrm{unit}_S : S\to\mathcal{P}(S)$</td>
<td style="text-align: center;">return :: T -&gt; [T]</td>
</tr>
<tr>
<td style="text-align: center;">$\mathrm{join}_S : \mathcal{P}(\mathcal{P}(S))\to\mathcal{P}(S)$</td>
<td style="text-align: center;">join :: [[T]] -&gt; [T]</td>
</tr>
</tbody>
</table>
</details>
<details class="abstract" open="open">
<summary>态射<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>函数的定义</summary>
<table>
<thead>
<tr>
<th style="text-align: center;">幂集函子</th>
<th style="text-align: center;"><span>Haskell<span class="heti-spacing"> </span></span>中列表</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">$(\mathcal{P}(f))(S) = \{f(a):a\in S\}$</td>
<td style="text-align: center;">fmap f xs = [ f a | a &lt;- xs ]</td>
</tr>
<tr>
<td style="text-align: center;">$\mathrm{unit}_S(x) = \{x\}$</td>
<td style="text-align: center;">return x = [x]</td>
</tr>
<tr>
<td style="text-align: center;">$\mathrm{join}_S(L) = \bigcup L$</td>
<td style="text-align: center;">join xs = concat xs</td>
</tr>
</tbody>
</table>
</details>
<h4 id="_29">单子公理<a class="headerlink" href="#_29" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h4>
<p>给定一个单子<span><span class="heti-spacing"> </span>$M : \mathbf{C}\to\mathbf{C}$</span>，和一个态射<span><span class="heti-spacing"> </span>$f : A\to B$</span>（其中<span><span class="heti-spacing"> </span>$A,B\in \mathbf{C}$</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么满足下面四条定律：</p>
<ol>
<li>$\mathrm{join}\circ M(\mathrm{join})=\mathrm{join}\circ\mathrm{join}$</li>
<li>$\mathrm{join}\circ M(\mathrm{unit})=\mathrm{join}\circ\mathrm{unit}=\mathrm{id}$</li>
<li>$\mathrm{unit}\circ f = M(f)\circ\mathrm{unit}$</li>
<li>$\mathrm{join}\circ M(M(f)) = M(f)\circ\mathrm{join}$</li>
</ol>
<p>也可以很自然地将其转化为<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>中的表述：</p>
<ol>
<li>join . fmap join = join . join </li>
<li>join . fmap return = join . return = id </li>
<li>return . f = fmap f . return </li>
<li>join . fmap (fmap f) = fmap f . join</li>
</ol>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>中，使用 <code>&gt;&gt;=</code> 也有三个定律和这四个定律是等价的：</p>
<ol>
<li>return x &gt;&gt;= f = f x 
  <code>haskell 
    return x &gt;&gt;= f 
  = join (fmap f (return x)) = join (fmap f . return $ x)
  = join (return (f x)) = join (return . f $ x)
  = join . return $ (f x)
  = id (f x)
  = f x</code></li>
<li>m &gt;&gt;= return = m
  <code>haskell 
    m &gt;&gt;= return 
  = join (fmap return m) = join . fmap return $ m 
  = id m
  = m</code></li>
<li>(m &gt;&gt;= f) &gt;&gt;= g = m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)
  <code>haskell 
    (m &gt;&gt;= f) &gt;&gt;= g 
  = (join (fmap f m)) &gt;&gt;= g = join (fmap g (join (fmap f m)))
  = join . fmap g . join $ fmap f m 
  = join . join . fmap (fmap g) $ fmap f m 
  = join . join . fmap (fmap g) . fmap f $ m 
  = join . join . fmap (fmap g . f) $ m 
  = join . fmap join . fmap (fmap g . f) $ m 
  = join . fmap (join . (fmap g . f)) $ m 
  = join . fmap (\x -&gt; join (fmap g (f x))) $ m 
  = join . fmap (\x -&gt; f x &gt;&gt;= g) $ m 
  = join (fmap (\x -&gt; f x &gt;&gt;= g) m)
  = m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code></li>
</ol>
<p>有关<span class="heti-skip"><span class="heti-spacing"> </span>do<span class="heti-spacing"> </span></span>语句和 <code>&gt;=&gt;</code> 的公理表述在上文中已经说过</p>
<hr/>
<h2 id="_30">后记<a class="headerlink" href="#_30" title="Permanent link"><span><span class="heti-spacing"> </span>#</span></a></h2>
<p>啃了将近一个月，算是把<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>的主要内容都啃完了。主要就是前期看<a href="http://learnyouahaskell.com/chapters"><span><span class="heti-spacing"> </span>Learn You a Haskell</span></a>，后期看<a href="https://wiki.haskell.org/Typeclassopedia"><span><span class="heti-spacing"> </span>Typeclassopedia</span></a>，都是<span class="heti-skip"><span class="heti-spacing"> </span>pdcxs<span class="heti-spacing"> </span></span>推荐给的教程。但是一堆视频一个都没有耐心看进去<span><span class="heti-spacing"> </span>qwq</span></p>
<p>后面的部分的理解感觉也没到位，Category、<span>Arrow<span class="heti-spacing"> </span></span>等这些类型类也就是大致地看了一眼，甚至有什么用都不太清楚<span><span class="heti-spacing"> </span>_(:</span>з」∠)_</p>
<p>感觉<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>这门语言确实很神奇，很多语法都很有意思，而且可以做到非常贴近数学、贴近数学概念。学的时候也是越学坑越多，先是函数式编程引申到了<span class="heti-skip"><span class="heti-spacing"> </span>lambda<span class="heti-spacing"> </span></span>演算，然后是函子等一系列概念引申到了范畴论，目前范畴论简单地看了一部分，<span>lambda<span class="heti-spacing"> </span></span>演算也没深入研究，以后有时间再说了（咕咕咕）</p>
<p>现在感觉我学到的<span class="heti-skip"><span class="heti-spacing"> </span>Haskell<span class="heti-spacing"> </span></span>简直是皮毛，还有一堆源码里的东西不知道是怎么回事（包括但不限于<span><span class="heti-spacing"> </span>#</span>，~<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，也还有一堆类型类和用法没有学到（包括但不限于<span><span class="heti-spacing"> </span>Monad Transformer</span>、Writer、Reader、State、Comonad、MonadFix、Lens、Parsec、……）~~md，这么一看差的还真多<span><span class="heti-spacing"> </span>~~</span>，以后有时间再慢慢学了，这个假期还有好多其它事要干呢，<span>Haskell<span class="heti-spacing"> </span></span>这边先摸了<span><span class="heti-spacing"> </span>_(:</span>з」∠)_</p>
<h2 id="reference">Reference<a class="headerlink" href="#reference" title="Permanent link">#</a></h2>
<ul>
<li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell</a></li>
<li><a href="https://stackoverflow.com/questions/6172004/writing-foldl-using-foldr">Writing foldl using foldr - StackOverflow</a></li>
<li><a href="https://blog.csdn.net/WinterShiver/article/details/103308165">Haskell：用<span class="heti-skip"><span class="heti-spacing"> </span>foldr<span class="heti-spacing"> </span></span>定义<span><span class="heti-spacing"> </span>foldl</span></a></li>
<li><a href="https://wiki.haskell.org/Typeclassopedia">Typeclassopedia - Haskell wiki</a></li>
<li><a href="https://hoogle.haskell.org/">Hoogle</a></li>
<li><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a></li>
<li><a href="http://02s949.coding-pages.com/2018/08/15/haskellc/"><span>Haskell<span class="heti-spacing"> </span></span>学习<span><span class="heti-spacing"> </span>- functor</span></a></li>
<li><a href="https://blog.csdn.net/zwvista/article/details/54863519"><span>Haskell<span class="heti-spacing"> </span></span>语言学习笔记（8）Monoid - zwvista</a></li>
<li><a href="https://blog.csdn.net/zwvista/article/details/62238541"><span>Haskell<span class="heti-spacing"> </span></span>语言学习笔记（16）Alternative - zwvista</a></li>
<li><a href="https://blog.csdn.net/zwvista/article/details/78679542"><span>Haskell<span class="heti-spacing"> </span></span>语言学习笔记（40）Arrow（1） - zwvista</a></li>
<li><a href="https://ocharles.org.uk/blog/guest-posts/2014-12-21-arrows.html">24 Days of GHC Extensions: Arrows - Tom Ellis</a></li>
<li><a href="https://blog.csdn.net/zwvista/article/details/78690485"><span>Haskell<span class="heti-spacing"> </span></span>语言学习笔记（47）Arrow（2） - zwvista</a></li>
<li><a href="https://en.wikibooks.org/wiki/Haskell/Category_theory">Haskell/Category theory - wikibooks</a></li>
<li><a href="https://en.wikipedia.org/wiki/Category_theory">Category theory - wikipedia</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%8C%83%E7%95%B4%E8%AE%BA">范畴论<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>维基百科</a></li>
<li><a href="https://en.wikipedia.org/wiki/Monad_(category_theory)">Monad (category theory) - wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Functor">Functor - wikipedia</a></li>
</ul>
<p style="text-align: center; font-size: x-large; font-weight: bolder"> "The End?" </p>
</article>
</div>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
      Material for MkDocs
    </a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "..", "features": [], "search": "../assets/javascripts/workers/search.f886a092.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
<script src="../assets/javascripts/bundle.d7c377c4.min.js"></script>
<script>document$.subscribe(() => {const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});})</script></body>
</html>